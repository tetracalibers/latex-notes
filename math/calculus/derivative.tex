\documentclass[../../imaging-math]{subfiles}

\begin{document}

\section{1変数関数の微分}

微分とは、複雑な問題も「拡大して見たら簡単に見える（かもしれない）」という発想で、わずかな変化に着目して入力と出力の関係（関数）を調べる手法といえる。

\subsection{接線：拡大したら直線に近似できる}

関数$y=f(x)$について、引数の値を$x=x_0$からわずかに増加させて、$x=x_0+\Delta x$にした場合の出力の変化を考える。

\begin{center}
  \scalebox{1.75}{
    \begin{tikzpicture}
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{1.5};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0) [below, scale=0.5]{$\strut x_0 + \Delta x$};
      \node (X1) at (\xi,0) [below, scale=0.5, baseline = (X2.base)]{$\strut x_0$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x_0)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x_0 + \Delta x)$};

      % x軸からの補助線
      \draw[auxline, thin, lightgray] (\xi,0) -- (A);
      \draw[auxline, thin, lightgray] (\xj,0) -- (B);

      % y軸からの補助線
      \draw[auxline, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[auxline, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % \Delta xを表す矢印
      \draw[<->] ($(A)-(0,0.1)$) -- ($(B)-(0,0.1)$) node [midway, below]{$\Delta x$};
    \end{tikzpicture}
  }
\end{center}

このとき、増分の幅$\Delta x$を狭くしていく（$\Delta x$の値を小さくしていく）と、$x=x_0$付近において、関数$y=f(x)$のグラフは直線にほとんど重なるようになる。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}[spy using outlines={circle, magnification=4, size=2cm, connect spies}]
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{0.95};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % x軸からの補助線
      \draw[dotted, thin, lightgray] (\xi,0) -- (A);
      \draw[dotted, thin, lightgray] (\xj,0) -- (B);
      % y軸からの補助線
      \draw[dotted, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[dotted, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0) [below right, scale=0.5]{$\strut x_0 + \Delta x$};
      \node (X1) at (\xi,0) [below, scale=0.5, baseline = (X2.base)]{$\strut x_0$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x_0)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x_0 + \Delta x)$};

      \spy [Aquamarine] on ($(A)!.5!(C)$) in node [left] at (3.5,-1.25);
    \end{tikzpicture}
  }
\end{center}

このように、関数$f(x)$は、ある点$x_0$の付近では、

\begin{equation}
  f(x) \simeq a(x - x_0) +b
\end{equation}

という直線に近似することができる。

\vskip\baselineskip

ここで、$f(x_0)$の値を考えると、

\begin{align}
  f(x_0) & = a(x_0 - x_0) + b \\
         & = a\cdot 0 + b     \\
         & = b
\end{align}

であるから、実は$b=f(x_0)$である。

\vskip\baselineskip

一方、$a$はこの直線の傾きを表す。

そもそも、傾きとは、$x$が増加したとき、$y$がどれだけ急に（速く）増加するかを表す量である。

関数のグラフを見ると、急激に上下する箇所もあれば、なだらかに変化する箇所もある。

つまり、ある点でグラフにぴったりと沿う直線（接線）を見つけたとしても、その傾きは場所によって異なる。

そこで、「傾きは位置$x$の関数」とみなして、次のように表現しよう。

\begin{equation}
  a = f'(x)
\end{equation}

これで、先ほどの直線の式を完成させることができる。

\begin{theorem}{関数の各点での直線による近似}\label{theorem:関数の各点での直線による近似}
  \titlegap
  関数$f(x)$は、ある点$x_0$の付近では、
  \Large
  \begin{equation}
    f(x) \simeq f(x_0) + f'(x)(x - x_0)
  \end{equation}
  \normalsize
  という傾き$f'(x)$の直線に近似できる。
\end{theorem}

\subsection{接線の傾きとしての導関数}

傾きは位置$x$の関数$f'(x)$としたが、この関数がどのような関数なのか、結局傾きを計算する方法がわかっていない。

直線の傾きは$x$と$y$の増加率の比として定義されているから、まずはそれぞれの増加率を数式で表現しよう。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{1.5};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0) [below, scale=0.5]{$\strut x + \Delta x$};
      \node (X1) at (\xi,0) [below, scale=0.5, baseline = (X2.base)]{$\strut x$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x + \Delta x)$};

      % x軸からの補助線
      \draw[auxline, thin, lightgray] (\xi,0) -- (A);
      \draw[auxline, thin, lightgray] (\xj,0) -- (B);

      % y軸からの補助線
      \draw[auxline, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[auxline, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % \Delta xを表す矢印
      \draw[<->] ($(A)-(0,0.1)$) -- ($(B)-(0,0.1)$) node [midway, below]{$\Delta x$};
      % \Delta yを表す矢印
      \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
    \end{tikzpicture}
  }
\end{center}

この図から、$y$の増加率$\Delta y$は次のように表せることがわかる。

\begin{equation}
  \Delta y = f(x + \Delta x) - f(x)
\end{equation}

この両辺を$\Delta x$で割ると、$x$の増加率$\Delta x$と$y$の増加率$\Delta y$の比率が表せる。

\begin{equation}
  \frac{\Delta y}{\Delta x} = \frac{f(x + \Delta x) - f(x)}{\Delta x}
\end{equation}

図では$\Delta x$には幅があるが、この幅を限りなく$0$に近づけると、幅というより点になる。

つまり、$\Delta x \rightarrow 0$とすれば、$\dfrac{\Delta y}{\Delta x}$は任意の点$x$での接線の傾きとなる。

「任意の点$x$での傾き」も$x$の関数であり、この関数を導関数と呼ぶ。

\begin{definition}{導関数}
  \titlegap
  関数$f(x)$の任意の点$x$における接線の傾き（増加の速さ）を表す関数を導関数といい、次のように定義する。
  \Large
  \begin{equation}
    f'(x) = \lim_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}
  \end{equation}
\end{definition}

\subsection{微分とその関係式}

\begin{definition}{微分}
  関数$f(x)$から、その導関数$f'(x)$を求める操作を微分という。
\end{definition}

関数のグラフから離れて、微分という「計算」を考えるにあたって、先ほどの導関数の定義式よりも都合の良い表現式がある。

$x \to 0$とした後の$\Delta x$を$dx$と書くことにして、$\displaystyle\lim_{\Delta x \to 0}$を取り払ってしまおう。

\begin{equation}
  \begin{WithArrows}
    f'(x) & = \dfrac{f(x + dx) - f(x)}{dx} \Arrow{両辺$\times dx$} \\
    f'(x)dx & = f(x + dx) - f(x) \Arrow{$f(x)$を移項} \\
    f'(x)dx + f(x) & = f(x + dx)
  \end{WithArrows}
\end{equation}

\begin{theorem}{微分の関係式}
  \Large
  \begin{equation}
    f(x + dx)= f(x) + f'(x)dx
  \end{equation}
\end{theorem}

\subsection{不連続点と微分可能性}

点$x$において連続な関数であれば、幅$\Delta x$を小さくすれば、その間の変化量$\Delta y$も小さくなるはずである。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{1};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0.1) [below right, scale=0.5]{$\strut x + \Delta x$};
      \node (X1) at (\xi,0.1) [below, scale=0.5, baseline = (X2.base)]{$\strut x$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x + \Delta x)$};

      % x軸からの補助線
      \draw[auxline, thin, lightgray] (\xi,0) -- (A);
      \draw[auxline, thin, lightgray] (\xj,0) -- (B);

      % y軸からの補助線
      \draw[auxline, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[auxline, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % \Delta xを表す矢印
      \draw[<->] ($(A)-(0,0.1)$) -- ($(B)-(0,0.1)$) node [midway, below]{$\Delta x$};
      % \Delta yを表す矢印
      \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
    \end{tikzpicture}
  }
\end{center}

しかし、不連続な点について考える場合は、そうはいかない。

下の図を見ると、$\Delta x$の幅を小さくしても、$\Delta y$は不連続点での関数の値の差の分までしか小さくならない。

\begin{figure}[H]
  \begin{minipage}{0.5\hsize}
    \centering
    \scalebox{1.5}{\begin{tikzpicture}
        \def\xmin{-1};
        \def\xmax{3};
        \def\ymin{-1};
        \def\ymax{3};
        \def\fnA#1{0.5*sin(deg(0.5*pi*#1))+1};
        \def\fnB#1{-0.5*cos(deg(0.5*pi*#1+0.25))+2};
        \def\xi{1};
        \def\xj{1.5};

        % よく使う点の座標
        \coordinate (O) at (0,0);
        \coordinate (A) at (\xi, {\fnA{\xi}});
        \coordinate (B) at (\xj, {\fnB{\xj}});
        \coordinate (C) at (\xj, {\fnA{\xi}});
        \coordinate (D) at (A |- B);

        % 原点
        \node at (O) [below left]{$O$};

        % 座標軸
        \draw[axis] (\xmin,0) -- (\xmax,0) node[right] {$x$};
        \draw[axis] (0,\ymin) -- (0,\ymax) node[above] {$y$};

        % 関数の描画
        \draw[domain=\xmin:\xi, samples=100, magenta,thick, smooth] plot (\x, {\fnA{\x}});
        \draw[domain=\xi:\xmax, samples=100, magenta,thick, smooth] plot (\x, {\fnB{\x}});

        % x軸上の目盛り
        \node (X2) at (\xj,0.15) [below right, scale=0.75]{$\strut x + \Delta x$};
        \node (X1) at (\xi,0.15) [below left, scale=0.75, baseline = (X2.base)]{$\strut x$};

        % y軸上の目盛り
        \node at (0,{\fnA{\xi}}) [left, scale=0.75]{$f(x)$};
        \node at (0,{\fnB{\xj}}) [left, scale=0.75]{$f(x + \Delta x)$};

        % x軸からの補助線
        \draw[auxline, thin, lightgray] (\xi,0) -- (A);
        \draw[auxline, thin, lightgray] (\xj,0) -- (B);

        % y軸からの補助線
        \draw[auxline, thin, lightgray] (0,{\fnA{\xi}}) -- (A);
        \draw[auxline, thin, lightgray] (0,{\fnB{\xj}}) --(B);

        % \Delta xを表す矢印
        \draw[<->] ($(A)-(0,0.1)$) -- ($(C)-(0,0.1)$) node [midway, below]{$\Delta x$};
        % \Delta yを表す矢印
        \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
      \end{tikzpicture}
    }
  \end{minipage}%
  \begin{minipage}{0.5\hsize}
    \centering
    \scalebox{1.5}{
      \begin{tikzpicture}
        \def\xmin{-1};
        \def\xmax{3};
        \def\ymin{-1};
        \def\ymax{3};
        \def\fnA#1{0.5*sin(deg(0.5*pi*#1))+1};
        \def\fnB#1{-0.5*cos(deg(0.5*pi*#1+0.25))+2};
        \def\xi{1};
        \def\xj{1};

        % よく使う点の座標
        \coordinate (O) at (0,0);
        \coordinate (A) at (\xi, {\fnA{\xi}});
        \coordinate (B) at (\xj, {\fnB{\xj}});
        \coordinate (C) at (\xj, {\fnA{\xi}});
        \coordinate (D) at (A |- B);

        % 原点
        \node at (O) [below left]{$O$};

        % 座標軸
        \draw[axis] (\xmin,0) -- (\xmax,0) node[right] {$x$};
        \draw[axis] (0,\ymin) -- (0,\ymax) node[above] {$y$};

        % 関数の描画
        \draw[domain=\xmin:\xi, samples=100, magenta,thick, smooth] plot (\x, {\fnA{\x}});
        \draw[domain=\xi:\xmax, samples=100, magenta,thick, smooth] plot (\x, {\fnB{\x}});

        % x軸上の目盛り
        \node (X2) at (\xj,0) [below, scale=0.6]{$ (x+ \Delta x) \simeq x$};

        % y軸上の目盛り
        \node at (0,{\fnA{\xi}}) [left, scale=0.75]{$f(x)$};
        \node at (0,{\fnB{\xj}}) [left, scale=0.75]{$f(x + \Delta x)$};

        % x軸からの補助線
        \draw[auxline, thin, lightgray] (\xi,0) -- (A);
        \draw[auxline, thin, lightgray] (\xj,0) -- (B);

        % y軸からの補助線
        \draw[auxline, thin, lightgray] (0,{\fnA{\xi}}) -- (A);
        \draw[auxline, thin, lightgray] (0,{\fnB{\xj}}) --(B);

        % \Delta xを表す矢印
        \draw ($(A)-(0,0.1)$) -- ($(C)-(0,0.1)$) node [midway, below]{$\Delta x$};
        % \Delta yを表す矢印
        \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
      \end{tikzpicture}
    }
  \end{minipage}
\end{figure}

このような不連続点においては、どんなに拡大しても、関数のグラフが直線にぴったりと重なることはない。

「拡大すれば直線に近似できる」というのが微分の考え方だが、不連続点ではこの考え方を適用できないのだ。

\vskip\baselineskip

関数の不連続点においては、微分という計算を考えることがそもそもできない。

ある点での関数のグラフが直線に重なる（微分可能である）ためには、$\Delta x \to 0$としたときに$\Delta y \to 0$となる必要がある。

\subsection{導関数のさまざまな記法}

微分を考えるときは、$\Delta x \to 0$としたときに$\Delta y \to 0$となる前提のもとで議論する。

$\Delta x \to 0$とした結果を$dx$、$\Delta y \to 0$の結果を$dy$とすると、ある点$x$での接線の傾きは、次のようにも表現できる。

\begin{equation}
  \frac{dy}{dx} = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}
\end{equation}

この接線の傾きが$x$の関数であることを表現したいときは、次のように書くこともある。

\begin{equation}
  \dfrac{dy}{dx}(x)
\end{equation}

これも一つの導関数（位置に応じた接線の傾きを表す関数）の表記法である。

この記法は、どの変数で微分しているかがわかりやすいという利点がある。

\begin{definition}{導関数のライプニッツ記法}
  \titlegap
  次のような記号はいずれも、関数$y = f(x)$の導関数を表す。
  \Large
  \begin{equation}
    \frac{dy}{dx} = \dfrac{dy}{dx}(x) = \dfrac{df}{dx} = \dfrac{d}{dx}f(x)
  \end{equation}
\end{definition}

特に、$\dfrac{d}{dx}f(x)$という記法は、$\dfrac{d}{dx}$の部分を微分操作を表す演算子として捉えて、「関数$f(x)$に微分という操作を施した」ことを表現しているように見える。

\begin{definition}{微分演算子}
  \titlegap
  関数を微分するという操作を表現する演算子を微分演算子という。\\
  例えば、次のような記号で表される。
  \Large
  \begin{equation}
    \dfrac{d}{dx}
  \end{equation}
\end{definition}

ところで、これまで使ってきた$f'(x)$という導関数の記法にも、名前がついている。

\begin{definition}{導関数のニュートン記法}
  \titlegap
  次の記号は、関数$y = f(x)$の導関数を表す。
  \Large
  \begin{equation}
    f'(x)
  \end{equation}
\end{definition}

この記法は、「$f$という関数から導出された関数が$f'$である」ことを表現している。

導関数はあくまでも関数$f$から派生したものであるから、$f$という文字はそのまま、加工されたことを表すために$'$をつけたものと解釈できる。

\subsection{微分の性質}

微分の関係式を使うことで、微分に関する有用な性質を導くことができる。

\begin{review}
  微分の関係式
  \begin{equation}
    f(x + dx)= \origFn{f(x)} + \derivFn{f'(x)} dx
  \end{equation}
\end{review}

\subsubsection{関数の一次結合の微分}

$\alpha f(x) + \beta g(x)$において、$x$を$dx$だけ微小変化させてみる。
\begin{align}
  \alpha f(x+dx) + \beta g(x+dx)
   & = \alpha \left\{ f(x) + f'(x) dx \right\} + \beta \left\{ g(x) + g'(x) dx \right\}    \\
   & = \origFn{ \alpha f(x) + \beta g(x) }+ \{ \derivFn{ \alpha f'(x) + \beta g'(x)} \} dx
\end{align}

\begin{theorem}{微分の線形性}
  \Large
  \begin{equation}
    \left( \alpha f(x) + \beta g(x) \right)' = \alpha f'(x) + \beta g'(x)
  \end{equation}
\end{theorem}

\subsubsection{関数の積の微分}

$f(x)g(x)$において、$x$を$dx$だけ微小変化させてみる。

\begin{align}
  f(x+dx)g(x+dx)
   & = \left\{ f(x) + f'(x) dx \right\} \left\{ g(x) + g'(x) dx \right\}                                            \\
   & = f(x)g(x) + f'(x)g(x)dx + f(x)g'(x)dx +  f'(x)g'(x)dx^2                                                       \\
   & = f(x)g(x) + \{ f'(x)g(x) + f(x)g'(x) \}dx + \fitLabelMath[BlueGreen][BlueGreen!40]{ f'(x)g'(x)dx^2}{2次以上の微小量}
\end{align}

ここで、$dx^2$は、$dx$より速く$0$に近づくので無視できる。

荒く言ってしまえば、$dx$でさえ微小量なのだから、$dx^2$なんて存在しないも同然だと考えてよい。

このことは、次の図を見るとイメージできる。

\begin{center}
  \begin{tikzpicture}
    \def\width{6}
    \def\height{4}
    \def\dx{2.25}

    % 座標
    \coordinate (A) at (0,0);
    \coordinate (B) at (\width,0);
    \coordinate (C) at (\width,\height);
    \coordinate (D) at (0,\height);
    \coordinate (Cx) at ($(C)+(\dx,0)$);
    \coordinate (Cy) at ($(C)+(0,\dx)$);
    \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
    \coordinate (Bx) at ($(B)+(\dx,0)$);
    \coordinate (Dy) at ($(D)+(0,\dx)$);

    % % 点（デバッグ用）
    % \fill (A) circle[radius=2pt] node[below left] {A};
    % \fill (B) circle[radius=2pt] node[below right] {B};
    % \fill (C) circle[radius=2pt] node[above right] {C};
    % \fill (D) circle[radius=2pt] node[above left] {D};
    % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
    % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
    % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
    % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
    % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

    % 長方形
    \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$f(x)g(x)$};
    \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx) node[pos=.5] {$f'(x)g(x)dx$};
    \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy) node[pos=.5] {$f(x)g'(x)dx$};
    \draw [fill=BlueGreen!30, draw=BlueGreen!70!gray] (C) rectangle (Cxy) node[pos=.5] {$f'(x)g'(x)dx^2$};

    % 補助線
    \def\l{1} % 補助線の長さ
    \draw[auxline] (B) -- ++(0, -\l) node[below] {$f(x)$};
    \draw[auxline] (Bx) -- ++(0, -\l) node[below] {$f(x+dx)$};
    \draw[auxline] (D) -- ++(-\l, 0) node[left] {$g(x)$};
    \draw[auxline] (Dy) -- ++(-\l, 0) node[left] {$g(x+dx)$};

    % 辺の長さを表す矢印
    \def\s{1em} % 辺と矢印の隙間
    \def\h{0.1} % 矢印の矢同士の隙間
    \draw[<->, thick, gray] ($(A)+(\h,-\s)$) -- ($(B)-(\h,\s)$) node[midway,below] {$f(x)$};
    \draw[<->, thick, gray] ($(A)+(-\s,\h)$) -- ($(D)-(\s,\h)$) node[midway,left] {$g(x)$};
    \draw[<->, thick, magenta!80] ($(B)+(\h,-\s)$) -- ($(Bx)-(\h,\s)$) node[midway,below] {$f'(x)dx$};
    \draw[<->, thick, magenta!80] ($(D)+(-\s,\h)$) -- ($(Dy)-(\s,\h)$) node[midway,left] {$g'(x)dx$};
  \end{tikzpicture}
\end{center}

$dx \to 0$のとき$dy \to 0$となる場合に微分という計算を定義するのだから、$dx$を小さくしていくと、$dy$にあたる$f(x + dx) - f(x)$（これは$f'(x)dx$と等しい）も小さくなっていく。

同様にして、$g(x + dx) - g(x)$（これは$g'(x)dx$と等しい）も小さくなっていく。

\begin{review}
  微分の関係式$f(x + dx)= f(x) + f'(x) dx$より、
  \large
  \begin{equation}
    \textcolor{magenta!80}{f'(x)dx} = f(x + dx) - f(x)
  \end{equation}
\end{review}

$dx$を小さくした場合を図示すると、

\begin{center}
  \begin{tikzpicture}
    \def\width{6}
    \def\height{4}
    \def\dx{0.15}

    % 座標
    \coordinate (A) at (0,0);
    \coordinate (B) at (\width,0);
    \coordinate (C) at (\width,\height);
    \coordinate (D) at (0,\height);
    \coordinate (Cx) at ($(C)+(\dx,0)$);
    \coordinate (Cy) at ($(C)+(0,\dx)$);
    \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
    \coordinate (Bx) at ($(B)+(\dx,0)$);
    \coordinate (Dy) at ($(D)+(0,\dx)$);

    % % 点（デバッグ用）
    % \fill (A) circle[radius=2pt] node[below left] {A};
    % \fill (B) circle[radius=2pt] node[below right] {B};
    % \fill (C) circle[radius=2pt] node[above right] {C};
    % \fill (D) circle[radius=2pt] node[above left] {D};
    % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
    % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
    % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
    % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
    % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

    % 長方形
    \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$f(x)g(x)$};
    \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx);
    \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy);
    \draw [fill=BlueGreen!40, draw=BlueGreen!70!gray] (C) rectangle (Cxy);
  \end{tikzpicture}
\end{center}

$\fitLabelMath[BlueGreen][BlueGreen!40]{f'(x)g'(x)dx^2}{\footnotesize 2次以上の微小量}$に相当する左上の領域は、ほとんど点になってしまうことがわかる。

\vskip\baselineskip

このように、$dx^2$の項は無視してもよいものとして、先ほどの計算式は次のようになる。

\begin{align}
  f(x+dx)g(x+dx)
   & = \origFn{f(x)g(x)} + \{ \derivFn{f'(x)g(x) + f(x)g'(x)} \}dx
\end{align}

\begin{theorem}{微分のライプニッツ則}\label{theorem:微分のライプニッツ則}
  \Large
  \begin{equation}
    \left( f(x) g(x) \right)' = f'(x) g(x) + f(x) g'(x)
  \end{equation}
\end{theorem}

\subsection{冪関数の微分}

具体的な関数の導関数も、微分の関係式をもとに考えることができる。

まずは、基本的な例として、冪関数$y=x^n$の微分を考えてみよう。

\subsubsection{$y=x^2$の微分}

$y=f(x)=x^2$において、$x$を$dx$だけ微小変化させると、$y$は$dy$だけ変化するとする。

すると、微分の関係式は$y + dy = f(x + dx) = (x+dx)^2$となるが、これを次のように展開して考える。

\begin{equation}
  y + dy = (x + dx)(x + dx)
\end{equation}

右辺の$(x+dx)(x+dx)$からは、

\begin{itemize}
  \item $x^2$の項が1つ
  \item $xdx$の項が2つ
  \item $dx^2$の項が1つ
\end{itemize}

現れることになる。

数式で表すと、

\begin{equation}
  \eqnmarkbox[magenta]{Y1}{y} + dy = \eqnmarkbox[magenta]{Y2}{x^2} + 2xdx + dx^2
\end{equation}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

ここで$y=x^2$なので、左辺の$y$と右辺の$x^2$は相殺される。

\begin{equation}
  dy = 2xdx + \fitLabelMath[BlueGreen][BlueGreen!40]{dx^2}{高次の微小量}
\end{equation}

さらに、$dx^2$の項は無視することができる。

なぜなら、$dx$を小さくすると、$dx^2$は$dx$とは比べ物にならないくらい小さくなってしまうからだ。

\begin{center}
  \begin{tikzpicture}
    \begin{scope}[local bounding box=left]
      \def\width{4}
      \def\dx{0.6}

      % 座標
      \coordinate (A) at (0,0);
      \coordinate (B) at (\width,0);
      \coordinate (C) at (\width,\width);
      \coordinate (D) at (0,\width);
      \coordinate (Cx) at ($(C)+(\dx,0)$);
      \coordinate (Cy) at ($(C)+(0,\dx)$);
      \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
      \coordinate (Bx) at ($(B)+(\dx,0)$);
      \coordinate (Dy) at ($(D)+(0,\dx)$);

      % % 点（デバッグ用）
      % \fill (A) circle[radius=2pt] node[below left] {A};
      % \fill (B) circle[radius=2pt] node[below right] {B};
      % \fill (C) circle[radius=2pt] node[above right] {C};
      % \fill (D) circle[radius=2pt] node[above left] {D};
      % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
      % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
      % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

      % 長方形
      \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$x^2$};
      \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx) node[pos=.5, rotate=-90] {$xdx$};
      \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy) node[pos=.5] {$xdx$};
      \draw [fill=BlueGreen!30, draw=BlueGreen!70!gray] (C) rectangle (Cxy) node[pos=.5] {$dx^2$};

      % 辺の長さを表す矢印
      \def\s{1em} % 辺と矢印の隙間
      \def\h{0.01} % 矢印の矢同士の隙間
      \draw[<->, thick, gray] ($(A)+(\h,-\s)$) -- ($(B)-(\h,\s)$) node[midway,below] {$x$};
      \draw[<->, thick, gray] ($(A)+(-\s,\h)$) -- ($(D)-(\s,\h)$) node[midway,left] {$x$};
      \draw[<->, thick, magenta!80] ($(B)+(\h,-\s)$) -- ($(Bx)-(\h,\s)$) node[midway,below] {$dx$};
      \draw[<->, thick, magenta!80] ($(D)+(-\s,\h)$) -- ($(Dy)-(\s,\h)$) node[midway,left] {$dx$};
    \end{scope}

    \begin{scope}[xshift=0.5\textwidth, local bounding box=right]
      \def\width{4}
      \def\dx{0.1}

      % 座標
      \coordinate (A) at (0,0);
      \coordinate (B) at (\width,0);
      \coordinate (C) at (\width,\width);
      \coordinate (D) at (0,\width);
      \coordinate (Cx) at ($(C)+(\dx,0)$);
      \coordinate (Cy) at ($(C)+(0,\dx)$);
      \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
      \coordinate (Bx) at ($(B)+(\dx,0)$);
      \coordinate (Dy) at ($(D)+(0,\dx)$);

      % % 点（デバッグ用）
      % \fill (A) circle[radius=2pt] node[below left] {A};
      % \fill (B) circle[radius=2pt] node[below right] {B};
      % \fill (C) circle[radius=2pt] node[above right] {C};
      % \fill (D) circle[radius=2pt] node[above left] {D};
      % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
      % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
      % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

      % 長方形
      \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$x^2$};
      \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx);
      \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy);
      \draw [fill=BlueGreen!30, draw=BlueGreen!70!gray] (C) rectangle (Cxy);
    \end{scope}

    \draw[->, thick] ($(left.east)+(1em, 0)$) -- ($(left-|right.west)-(1em,0)$) node[pos=.5, above] {$dx \to 0$};
  \end{tikzpicture}
\end{center}

というわけで、次のような式が得られる。

\begin{equation}
  dy = 2xdx
\end{equation}

よって、$y=x^2$の導関数は、$y'=2x$となることがわかった。

\begin{equation}
  \frac{dy}{dx} = 2x
\end{equation}

\subsubsection{$y=x^3$の微分}

同じように、$y=x^3$の微分を考えてみよう。

\begin{equation}
  y + dy = (x + dx)(x + dx)(x + dx)
\end{equation}

右辺の$(x+dx)(x+dx)(x+dx)$からは、

\begin{itemize}
  \item $x^3$の項が1つ
  \item $x^2dx$の項が3つ
  \item $dx^3$の項が1つ
\end{itemize}

現れることになる。

\begin{equation}
  \eqnmarkbox[magenta]{Y1}{y} + dy = \eqnmarkbox[magenta]{Y2}{x^3} + 3x^2dx + dx^3
\end{equation}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

ここで$y=x^3$なので、左辺の$y$と右辺の$x^3$は相殺される。

\begin{equation}
  dy = 3x^2dx + \fitLabelMath[BlueGreen][BlueGreen!40]{dx^3}{高次の微小量}
\end{equation}

さらにここでは、$dx^3$の項を無視することができる。

次の図を見てみよう。

各辺$dx$の立方体は、$dx$を小さくすると、ほぼ点にしか見えないほど小さくなる。

つまり、各辺$dx$の立方体の体積$dx^3$は、考慮する必要がない。

\begin{center}
  \tdplotsetmaincoords{60}{125}
  \begin{tikzpicture}[
      tdplot_main_coords,
      grid/.style={very thin,gray},
      axis/.style={->,blue,thick},
      cube/.style={very thick,fill=lightgray!20, draw=lightgray!80!gray},
      cube_dx/.style={very thick,fill=magenta!30, draw=magenta!70!gray, opacity=0.6},
      cube_dx3/.style={very thick,fill=BlueGreen!30, draw=BlueGreen!70!gray, opacity=0.6},
      cube hidden/.style={thick, dashed, draw=lightgray!80!gray}
    ]
    \begin{scope}[local bounding box=left]
      \def\size{3}
      \def\dx{0.6}

      % 頂点の座標
      \coordinate (O) at (0,0,0);
      \coordinate (Axy) at (\size, 0, 0);
      \coordinate (Bxy) at (\size, \size, 0);
      \coordinate (Cxy) at (0, \size, 0);
      \coordinate (Ayz) at (0, 0, \size);
      \coordinate (Byz) at (0, \size, \size);
      \coordinate (Axz) at (\size, 0, \size);
      \coordinate (Axyz) at (\size, \size, \size);

      %%% 元の立方体
      % draw the front-right of the cube
      \draw[cube] (Axy) -- (Bxy) -- (Axyz) -- (Axz) -- cycle;
      % draw the front-left of the cube
      \draw[cube] (Cxy) -- (Bxy) -- (Axyz) -- (Byz) -- cycle;
      % draw the top of the cube
      \draw[cube] (Ayz) -- (Byz) -- (Axyz) -- (Axz) -- cycle;

      %%% x軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- (Bxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Axz) -- (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- (Bxy) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- cycle;
      % 上面
      \draw[cube_dx] (Axz) -- ($(Axz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;

      %%% y軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Bxy) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- (Cxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Cxy) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- (Bxy) -- cycle;
      % 上面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- cycle;

      %%% z軸方向にdxだけ拡張
      % 後ろの面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- (Byz) -- cycle;
      % 左の面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- (Axz) -- cycle;
      % 右の面
      \draw[cube_dx] (Byz) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 前の面
      \draw[cube_dx] (Axz) -- ($(Axz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- cycle;

      %%% 高次の微小量
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(0,\dx,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(0,\dx,0)$) -- cycle; % 底面
      \draw[cube_dx3] ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,0,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle; % 上面

      %%% 辺の長さを表す矢印
      % 辺と矢印の隙間
      \def\s{0.4}
      % dxを表す矢印
      \draw[<->, thick, magenta!80] ($(Axz)+(\s,0,0.15)$) -- ($(Axz)+(\s,0,\dx + 0.15)$) node[midway,left] {$dx$};
      % xを表す矢印
      \draw[<->, thick, gray] ($(Axy)+(\dx + \s,0,0.1)$) -- ($(Axz)+(\dx + \s,0,0.1)$) node[midway,left] {$x$};

      % draw dashed lines to represent hidden edges
      \draw[cube hidden] (O) -- (Axy);
      \draw[cube hidden] (O) -- (Cxy);
      \draw[cube hidden] (O) -- (Ayz);

      % % 座標軸（デバッグ用）
      % \draw[axis] (0,0,0) -- (3,0,0) node[anchor=west]{$x$};
      % \draw[axis] (0,0,0) -- (0,3,0) node[anchor=west]{$y$};
      % \draw[axis] (0,0,0) -- (0,0,3) node[anchor=west]{$z$};
      % % 点（デバッグ用）
      % \fill (O) circle[radius=2pt] node[above left] {O};
      % \fill (Axy) circle[radius=2pt] node[below left] {Axy};
      % \fill (Bxy) circle[radius=2pt] node[below right] {Bxy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Ayz) circle[radius=2pt] node[above left] {Ayz};
      % \fill (Byz) circle[radius=2pt] node[above right] {Byz};
      % \fill (Axz) circle[radius=2pt] node[above left] {Axz};
      % \fill (Axyz) circle[radius=2pt] node[above right] {Axyz};
    \end{scope}

    \begin{scope}[xshift=0.5\textwidth, local bounding box=right]
      \def\size{3}
      \def\dx{0.15}

      % 頂点の座標
      \coordinate (O) at (0,0,0);
      \coordinate (Axy) at (\size, 0, 0);
      \coordinate (Bxy) at (\size, \size, 0);
      \coordinate (Cxy) at (0, \size, 0);
      \coordinate (Ayz) at (0, 0, \size);
      \coordinate (Byz) at (0, \size, \size);
      \coordinate (Axz) at (\size, 0, \size);
      \coordinate (Axyz) at (\size, \size, \size);

      %%% 元の立方体
      % draw the front-right of the cube
      \draw[cube] (Axy) -- (Bxy) -- (Axyz) -- (Axz) -- cycle;
      % draw the front-left of the cube
      \draw[cube] (Cxy) -- (Bxy) -- (Axyz) -- (Byz) -- cycle;
      % draw the top of the cube
      \draw[cube] (Ayz) -- (Byz) -- (Axyz) -- (Axz) -- cycle;

      %%% x軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- (Bxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Axz) -- (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- (Bxy) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- cycle;
      % 上面
      \draw[cube_dx] (Axz) -- ($(Axz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;

      %%% y軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Bxy) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- (Cxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Cxy) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- (Bxy) -- cycle;
      % 上面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- cycle;

      %%% z軸方向にdxだけ拡張
      % 後ろの面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- (Byz) -- cycle;
      % 左の面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- (Axz) -- cycle;
      % 右の面
      \draw[cube_dx] (Byz) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 前の面
      \draw[cube_dx] (Axz) -- ($(Axz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- cycle;

      %%% 高次の微小量
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(0,\dx,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(0,\dx,0)$) -- cycle; % 底面
      \draw[cube_dx3] ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,0,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle; % 上面

      % draw dashed lines to represent hidden edges
      \draw[cube hidden] (O) -- (Axy);
      \draw[cube hidden] (O) -- (Cxy);
      \draw[cube hidden] (O) -- (Ayz);

      % % 座標軸（デバッグ用）
      % \draw[axis] (0,0,0) -- (3,0,0) node[anchor=west]{$x$};
      % \draw[axis] (0,0,0) -- (0,3,0) node[anchor=west]{$y$};
      % \draw[axis] (0,0,0) -- (0,0,3) node[anchor=west]{$z$};
      % % 点（デバッグ用）
      % \fill (O) circle[radius=2pt] node[above left] {O};
      % \fill (Axy) circle[radius=2pt] node[below left] {Axy};
      % \fill (Bxy) circle[radius=2pt] node[below right] {Bxy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Ayz) circle[radius=2pt] node[above left] {Ayz};
      % \fill (Byz) circle[radius=2pt] node[above right] {Byz};
      % \fill (Axz) circle[radius=2pt] node[above left] {Axz};
      % \fill (Axyz) circle[radius=2pt] node[above right] {Axyz};
    \end{scope}

    \draw[->, thick] ($(left.east)+(1em, 0)$) -- ($(left-|right.west)-(1em,0)$) node[pos=.5, above] {$dx \to 0$};
  \end{tikzpicture}
\end{center}

というわけで、$y=x^3$の導関数は、$y'=3x^2$となることがわかった。

\begin{equation}
  \frac{dy}{dx} = 3x^2
\end{equation}

\subsubsection{$y=x^n$の微分（$n$が自然数の場合）}

$n$が自然数だとすると、$y=x^n$の微分は、$y=x^2$や$y=x^3$の場合と同じように考えられる。

\begin{equation}
  y + dy = \underbrace{(x+dx)(x+dx) \cdots (x+dx)}_{n\text{個}}
\end{equation}

右辺の$(x+dx)(x+dx) \cdots (x+dx)$を展開しようすると、次のような3種類のかけ算が発生する。

\begin{itemize}
  \item $x$どうしのかけ算
  \item $x$と$dx$のかけ算
  \item $dx$どうしのかけ算
\end{itemize}

つまり、右辺からは、

\begin{itemize}
  \item $x^n$の項が1つ
  \item $x^{n-1}dx$の項が$n$個
  \item $dx^n$の項が1つ
\end{itemize}

という項が現れることになる。

そして、$x^n$は左辺の$y$と相殺され、$dx^n$の項は高次の微小量として無視できる。

すると、残るのは次のような式になるだろう。

\begin{equation}
  dy = nx^{n-1}dx
\end{equation}

この式は、$y=\alpha x$という直線の式によく似ている。

高次の$dx$の項$dx^n$を無視し、1次の$dx$の項だけ残したのは、微分という計算が微小範囲における直線での近似であるからだ。

あくまでも微小範囲での直線の式であることを表すために、$x, y$を$dx, dy$として、$dy=\alpha dx$という形の式になっていると考えればよい。

\begin{theorem}{自然数の冪を持つ冪関数の導関数}
  \titlegap
  $n$が自然数のとき、$y=x^n$の導関数は次のようになる。
  \Large
  \begin{equation}
    \frac{dy}{dx} = nx^{n-1}
  \end{equation}
\end{theorem}

\subsubsection{$y=x^n$の微分（$n$が整数の場合）}

指数法則を使うことで、$n$が負の整数の場合にも拡張することができる。

\vskip\baselineskip

まずは、$y=x^{-1}$の微分を考えてみよう。

指数法則より、$y=x^{-1}$は次のように変形できる。

\begin{equation}
  \begin{WithArrows}
    y  & = \dfrac{1}{x} \Arrow{両辺$\times x$} \\
    xy & = 1
  \end{WithArrows}
\end{equation}

微小変化を加えた微分の関係式を作って、次のように展開していく。

\begin{align}
  (x +dx)(y+dy)                                                                                   & = 1                           \\
  \eqnmarkbox[magenta]{Y1}{xy} + xdy + ydx + \fitLabelMath[BlueGreen][BlueGreen!40]{dydx}{高次の微小量} & = \eqnmarkbox[magenta]{Y2}{1}
\end{align}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

ここで、微小量の掛け合わせである$dydx$は無視できるほど小さい。

また、$y=\dfrac{1}{x}$より、$xy=1$なので、左辺の$xy$と右辺の$1$は相殺される。

すると、残った式は、

\begin{equation}
  \begin{WithArrows}
    xdy + ydx       & = 0            \Arrow{$ydx$を移項} \\
    xdy             & = -ydx         \Arrow{両辺$\div dx$} \\
    x\dfrac{dy}{dx} & = -y           \Arrow{両辺$\div x$} \\
    \dfrac{dy}{dx}  & = -\dfrac{y}{x}
  \end{WithArrows}
\end{equation}

$y$が残ってしまっているので、$y=\dfrac{1}{x}$を代入すると、

\begin{align}
  \dfrac{dy}{dx} & = -\dfrac{1}{x^2} \\
                 & = -x^{-2}
\end{align}

これは、冪が自然数の場合の冪関数の微分$\dfrac{dy}{dx} = nx^{n-1}$において、$n = -1$を代入したものになっている。

\vskip\baselineskip

$n$が任意の負の整数の場合も、同様に考えられる。

$y=x^{-n}$を、$x^ny = 1$として、

\begin{equation}
  \begin{WithArrows}
    \underbrace{(x+dx)(x+dx) \cdots (x+dx)}_{n\text{個}}\times(y+dy)                           & = 1 \\
    ( x^n + nx^{n-1}dx + \fitLabelMath[BlueGreen][BlueGreen!40]{dx^n}{高次の微小量} ) \times (y+dy) & = 1 \Arrow{高次の微小量を無視} \\
    ( x^n + nx^{n-1}dx ) \times (y+dy)                                                        & = 1 \\
    \eqnmarkbox[magenta]{Y1}{x^ny} + x^ndy + nx^{n-1}ydx + \fitLabelMath[BlueGreen][BlueGreen!40]{nx^{n-1}dxdy}{高次の微小量}                                           & = \eqnmarkbox[magenta]{Y2}{1} \Arrow[jump=2]{相殺＆無視}\\\\
    x^ndy + nx^{n-1}ydx & = 0
  \end{WithArrows}
\end{equation}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

移項してさらに整理すると、

\begin{equation}
  \begin{WithArrows}
    x^ndy & = -nx^{n-1}ydx \Arrow{両辺$\div dx$} \\
    x^n\dfrac{dy}{dx} & = -nx^{n-1}y \Arrow{両辺$\times x^{-n}$} \\
    \dfrac{dy}{dx} & = -nx^{n-1}x^{-n}y \Arrow{$y=x^{-n}$} \\
    &= -nx^{n-1}x^{-n}x^{-n} \Arrow{指数法則$x^mx^n=x^{m+n}$} \\
    &= -nx^{-n-1}
  \end{WithArrows}
\end{equation}

これもやはり、冪が自然数の場合の冪関数の微分$\dfrac{dy}{dx} = nx^{n-1}$において、$n$を$-n$に置き換えたものになっている。

つまり、自然数（正の整数）だけでなく、負の整数も許容して、次のことがいえる。

\begin{theorem}{整数の冪を持つ冪関数の導関数}
  \titlegap
  $n$が整数のとき、$y=x^n$の導関数は次のようになる。
  \Large
  \begin{equation}
    \frac{dy}{dx} = nx^{n-1}
  \end{equation}
\end{theorem}

\subsubsection{$y=x^n$の微分（$n$が実数の場合）}

$n$が有理数の場合はどうだろうか。実はこれも、指数法則によって拡張することができる。

$m$と$n$はどちらも自然数として、$y=x^{\frac{m}{n}}$の微分を考える。

\vskip\baselineskip

まず、$y=x^{\frac{m}{n}}$は、$y^n = x^m$とまったく同じ式である。

\begin{equation}
  \begin{WithArrows}
    y^n & = x^m \Arrow{両辺$\dfrac{1}{n}$乗} \\
    y & = x^{\frac{m}{n}}
  \end{WithArrows}
\end{equation}

というわけで、$y^n = x^m$を微小変化させて、展開してみよう。

\begin{equation}
  \underbrace{(y+dy)(y+dy) \cdots (y+dy)}_{n\text{個}} = \underbrace{(x+dx)(x+dx) \cdots (x+dx)}_{m\text{個}}
\end{equation}

ここで、$n$と$m$は自然数なのだから、自然数冪のときと同じように考えて、次のような式が残ることになる。

\begin{equation}
  ny^{n-1}dy = mx^{m-1}dx
\end{equation}

よって、$\dfrac{dy}{dx}$の式の$y$を含まない形を目指すと、

\begin{equation}
  \begin{WithArrows}
    \dfrac{dy}{dx} &= \dfrac{mx^{m-1}}{ny^{n-1}} \Arrow{$y=x^{\frac{m}{n}}$} \\
    &= \dfrac{mx^{m-1}}{nx^{\frac{m}{n}(n-1)}} \\
    &= \dfrac{mx^{m-1}}{nx^{m - \frac{m}{n}}} \Arrow{指数法則$x^{a+b} = x^a x^b$} \\
    &= \dfrac{mx^m x^{-1}}{nx^mx^{-\frac{m}{n}}} \Arrow{$x^m$で約分} \\
    &= \dfrac{mx^{-1}}{n x^{-\frac{m}{n}}} \\
    &= \dfrac{m}{n}\cdot\dfrac{x^{-1}}{x^{-\frac{m}{n}}} \Arrow{指数法則$\dfrac{a^m}{a^n}=a^{m-n}$} \\
    &= \dfrac{m}{n}\cdot x^{-1-\left(-\frac{m}{n}\right)} \\
    &= \dfrac{m}{n}\cdot x^{-1 + \frac{m}{n}} \\
    &= \dfrac{m}{n}x^{\frac{m}{n}-1}
  \end{WithArrows}
\end{equation}

これは、冪が自然数の場合の冪関数の微分$\dfrac{dy}{dx} = nx^{n-1}$において、$n$を$\dfrac{m}{n}$に置き換えたものになっている。

つまり、整数だけでなく、有理数に対しても同様の導関数の式が成り立つ。

\vskip\baselineskip

ここまで来ると、無理数はどうだろうか？という疑問が生まれるが、無理数への拡張は指数法則では対応できない。

無理数に対しては、極限操作によって同様の導関数の式を導くことができ、実数全体に対して同じ導関数の式が成り立つことが示される。

\begin{theorem}{冪関数の導関数}
  \titlegap
  $n$が実数のとき、$y=x^n$の導関数は次のようになる。
  \Large
  \begin{equation}
    \frac{dy}{dx} = nx^{n-1}
  \end{equation}
\end{theorem}

\subsection{定数関数の微分}

常に一定の値$c$を返す定数関数$f(x) = c$の微分はどうなるだろうか。

関数のグラフを描いて考えてみよう。

\begin{center}
  \begin{tikzpicture}
    \def\xmin{-1};
    \def\xmax{3};
    \def\ymin{-1};
    \def\ymax{3};
    \def\c{1.2}

    % よく使う点の座標
    \coordinate (O) at (0,0);

    % 座標軸
    \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
    \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

    % 原点
    \node at (O) [below left]{$O$};

    % グラフ
    \draw[magenta,thick] (\xmin,\c) -- (\xmax,\c) node [right]{$y = c$};

    % y軸上の目盛り
    \node at (0,{\c}) [above left]{$c$};
  \end{tikzpicture}
\end{center}

定数関数のグラフは、$x$軸に対して平行な直線であり、この直線の傾きは見るからに$0$である。

実際、導関数の定義に従って計算することで、定数関数の導関数は$0$になることを確かめられる。

\begin{review}
  導関数の定義
  \begin{equation}
    f'(x) = \lim_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}
  \end{equation}
\end{review}

どの点$x$においても$f(x)$が$c$を返すということは、$f(x+\Delta x)$も$c$であるため、

\begin{align}
  f'(x) & = \lim_{\Delta x \to 0} \dfrac{c - c}{\Delta x} \\
        & = \lim_{\Delta x \to 0} \dfrac{0}{\Delta x}     \\
        & = 0
\end{align}

となり、定数関数$f(x) = c$の微分の結果は$c$に依存せず、常に$0$になる。

\begin{theorem}{定数関数の微分}
  \titlegap
  常に定数$c$の値をとる定数関数$f(x) = c$は、微分すると$0$になる。
  \LARGE
  \begin{equation}
    \dfrac{d}{dx} c = 0
  \end{equation}
\end{theorem}

\subsection{合成関数の微分}

合成関数の微分の一般的な式は、いろいろな関数の微分を考える上で重要な公式である。

\subsubsection{関数の微小変化量}

関数$f(x)$において、変数$x$を$dx$だけ微小変化させた式は、これまで何度も登場した。

\begin{equation}
  f(x + dx) = f(x) + \fitLabelMath{f'(x)dx}{増えた分}
\end{equation}

この式は、「$x$を$dx$だけ微小変化させることで、関数$f$の値は$f'(x)dx$だけ増加した」と捉えることもできる。

言い換えれば、関数$f$の微小変化量は$f'(x)dx$だということだ。

変化量という観点で眺めるには、次のように移項した式がわかりやすいかもしれない。

\begin{equation}
  \fitLabelMath{f(x + dx) - f(x)}{区間$dx$での変化} = \fitLabelMath{f'(x)dx}{変化量}
\end{equation}

関数$f$の微小変化量$f'(x)dx$を、$df$と表すことにしよう。

\subsubsection{合成関数の微分の関係式}

今回はさらに、$t= f(x)$を関数$g(t)$に放り込むことを考える。

$g(t)$についても、次のような微分の関係式が成り立つはずだ。

\begin{equation}
  g(t + dt) = g(t) + g'(t)dt
\end{equation}

合成関数$g(f(x))$を作るため、$t=f$（引数$(x)$を省略して書いた関数$f(x)$）を代入する。

\begin{equation}
  g(f + df) = g(f) + g'(f)df
\end{equation}

$f$を$f(x)$に、$df$を$f'(x)dx$に書き戻すと、

\begin{equation}
  g(f(x) + f'(x)dx) = g(f(x)) + g'(f(x))f'(x)dx
\end{equation}

となり、左辺の$g()$の中身$f(x) + f'(x)dx$は$f(x + dx)$と書き換えられるので、次の式を得る。

\begin{equation}
  g(f(x + dx)) = \origFn{g(f(x))} + \derivFn{g'(f(x))f'(x)}dx
\end{equation}

\begin{theorem}{合成関数の微分（ニュートン記法による表現）}
  \titlegap
  合成関数$g(f(x))$の微分は、次の式で表される。
  \Large
  \begin{equation}
    \left( g(f(x)) \right)' = f'(x)g'(f(x))
  \end{equation}
\end{theorem}

\subsubsection{連鎖律としての表現}

ニュートン記法による表現はなかなかに覚えづらい式に見えるが、ライプニッツ記法を使って書き直すと、実は単純な関係式になっている。

\begin{itemize}
  \item $\left( g(f(x)) \right)'$は、$g(f(x))$を$x$で微分したもの：$\dfrac{d}{dx} g(f(x))$
  \item $f'(x)$は、$f(x)$を$x$で微分したもの：$\dfrac{d}{dx} f(x)$
  \item $g'(f(x))$は、$g(t)$を$t$で微分したもの$\dfrac{d}{dt} g(t)$に、$t=f(x)$に代入したもの：$\dfrac{d}{df}g(f(x))$
\end{itemize}

として書き直すと、

\begin{equation}
  \dfrac{d}{dx} g(f(x)) = \dfrac{d}{dx}f(x) \cdot \dfrac{d}{df}g(f(x))
\end{equation}

さらに、引数を省略して書くと、

\begin{equation}
  \frac{dg}{dx} = \frac{df}{dx} \cdot \frac{dg}{df}
\end{equation}

これは、$df$を約分できると考えたら、当たり前の式になっている。

\begin{equation}
  \frac{dg}{dx} = \frac{\cancel{df}}{dx} \cdot \frac{dg}{\cancel{df}}
\end{equation}

\begin{theorem}{合成関数の微分（連鎖律：ライプニッツ記法による表現）}
  \titlegap
  $y=f(x)$、$z=g(y)$という関係があるとき、次の式が成り立つ。
  \LARGE
  \begin{equation}
    \frac{dz}{dx} = \frac{dz}{dy} \cdot \frac{dy}{dx}
  \end{equation}
  \normalsize
  これは、$x$が微小変化すると$y$も微小変化し、さらに連鎖して$z$も微小変化するという関係から、\hl{連鎖律}と呼ばれる。
\end{theorem}

\subsection{逆関数の微分}

関数$y=f(x)$の逆関数$x = f^{-1}(y)$の微分も、ライプニッツ記法で考えると、ごく当たり前の式として導出できる。

ネタバレすると、次の式がそのまま逆関数の微分を表すものになっている。

\begin{equation}
  \dfrac{dx}{dy} = \dfrac{1}{\dfrac{dy}{dx}}
\end{equation}

$\dfrac{dy}{dx}$を$f'(x)$と表記するなら、

\begin{equation}
  \dfrac{dx}{dy} = \dfrac{1}{f'(x)}
\end{equation}

である。この発想を納得するために、もう少し詳しく見ていこう。

\froufrou

$y=f(x)$の導関数$f'(x)$は、ライプニッツ記法では$\dfrac{dy}{dx}$と表記される。

\begin{equation}
  \frac{dy}{dx} = f'(x)
\end{equation}

ライプニッツ記法$\dfrac{dy}{dx}$には、「$y$で表される関数を$x$で微分する」という意味がこめられている。

ならば、逆関数$x = f^{-1}(y)$の導関数は、「$x$で表される関数を$y$で微分する」という意味で、$\dfrac{dx}{dy}$と表記できる。

\begin{equation}
  \frac{dx}{dy} = (f^{-1})'(y)
\end{equation}

ここで、$\dfrac{dy}{dx} = f'(x)$という式から、次の等式も成り立つと考えられる。

\begin{equation}
  \frac{dx}{dy} = \frac{1}{f'(x)}
\end{equation}

これは逆関数の導関数になっているが、逆関数が$y$の関数なのだから、その導関数$\dfrac{dx}{dy}$も$y$の関数であってほしい。

そこで、$x$を消すために$x = f^{-1}(y)$を代入することで、逆関数の導関数を完成させる。

\begin{equation}
  \frac{dx}{dy} = \frac{1}{f'(x)} \Bigg|_{x=f^{-1}(y)}
\end{equation}

\begin{theorem}{逆関数の微分}
  \titlegap
  逆関数の導関数は、元の関数の導関数の逆数になる。
  \LARGE
  \begin{equation}
    \frac{dx}{dy} = \frac{1}{f'(x)} \Bigg|_{x=f^{-1}(y)}
  \end{equation}
  \normalsize
  ここで、$\Bigg|_{x=f^{-1}(y)}$は、その直前の式を計算した後に、$x=f^{-1}(y)$を代入することを意味する。
\end{theorem}

\subsection{三角関数の微分}

角度$\theta$を$d\theta$だけ微小変化させたときの、三角形の高さの変化が$\sin\theta$の微小変化であり、底辺の長さの変化が$\cos\theta$の微小変化である。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}[scale=3]
      \coordinate (A) at (1,0);
      \coordinate (O) at (0,0);
      \coordinate (C1) at (30:1cm);
      \coordinate (C2) at (40:1cm);
      \coordinate (H) at (C1 |- O);
      % Hのx座標とC2のy座標を持つ点
      \coordinate (H2) at (C2 -| H);

      % 三角形O-H-C1
      \draw[fill=myPurple, opacity=0.6] (O) -- (H) -- (C1) -- cycle;
      % 三角形C1-H-C2
      \draw[fill=myPurple, opacity=0.6] (C2) -- (H2) -- (C1) -- cycle;

      % 角A-O-C1を表す扇形
      \draw (A) -- (O) -- (C1) pic [fill=cyan!50, angle radius=9mm, "$\theta$"] {angle = A--O--C1};
      % 角C1-O-C2を表す扇形
      \draw (C1) -- (O) -- (C2) pic [fill=magenta!40, angle radius=9mm] {angle = C1--O--C2};
      % 角C1-H-C2を表す扇形
      \draw (H2) -- (C1) -- (C2) pic [fill=cyan!60, angle radius=2mm] {angle = H2--C1--C2};

      % 直角O-H-C1
      \draw (O) -- (H) -- (C1) pic [fill=lightgray, angle radius=1.25mm] {right angle = O--H--C1};
      % 直角O-C1-C2
      \draw (O) -- (C1) --(C2) pic [fill=lightgray, angle radius=0.9mm] {right angle = O--C1--C2};
      % 直角C1-H2-C2
      \draw (C1) -- (H2) -- (C2) pic [fill=lightgray, angle radius=0.75mm] {right angle = C1--H2--C2};

      % AからC1を結ぶ円弧
      \draw[cyan, thick] (A) arc (0:30:1cm) node [midway, above, right] {$\theta$};
      % C1からC2を結ぶ円弧
      \draw[magenta, thick] (C1) arc (30:40:1cm) node [midway,sloped, below] {$d\theta$};

      % C1からH2の高さを表すベクトル
      \draw[->, -Straight Barb, semithick] ($(C1)+ (0.05, 0)$) -- ($(H2)+(0.05,0)$) node [midway, right] {$d\theta\cos \theta$};
      % C2からH2の幅を表すベクトル
      \draw[<-, Straight Barb-, semithick] ($(C2)+ (0, 0.05)$) -- ($(H2)+(0,0.05)$) node [midway, above] {$d\theta\sin \theta$};

      % OからC2の長さを表すベクトル
      \draw [<->, semithick, orange] to ($(O)!0.05!90:(C2)$) -- ($(C2)!-0.05!90:(O)$) node [midway, above, orange] { $1$ };
      % OからAの長さを表すベクトル
      \draw [<->, semithick, orange] to ($(O)-(0,0.05)$) -- ($(A)-(0,0.05)$) node [midway, below, orange] { $1$ };
    \end{tikzpicture}
  }
\end{center}

\begin{figure}[H]
  \centering
  \begin{minipage}{0.5\hsize}
    \centering
    \scalebox{1.5}{
      \begin{tikzpicture}[scale=3]
        \coordinate (O) at (0,0);
        \coordinate (C1) at (30:1cm);
        \coordinate (C2) at (40:1cm);
        \coordinate (H) at (C1 |- O);
        % Hのx座標とC2のy座標を持つ点
        \coordinate (H2) at (C2 -| H);

        % 三角形O-H-C1
        \draw[fill=myPurple, opacity=0.6] (O) -- (H) -- (C1) -- cycle;
        % 三角形C1-H-C2
        \draw[fill=myPurple, opacity=0.6] (C2) -- (H2) -- (C1) -- cycle;

        % 角A-O-C1を表す扇形
        \draw (H) -- (O) -- (C1) pic [fill=cyan!50, angle radius=9mm, "$\theta$"] {angle = H--O--C1};
        % 角C1-O-C2を表す扇形
        \draw (C1) -- (O) -- (C2) pic [fill=magenta!40, angle radius=9mm] {angle = C1--O--C2};
        % 角C1-H-C2を表す扇形
        \draw (H2) -- (C1) -- (C2) pic [fill=cyan!60, angle radius=2mm] {angle = H2--C1--C2};

        % 直角O-H-C1
        \draw (O) -- (H) -- (C1) pic [fill=lightgray, angle radius=1.25mm] {right angle = O--H--C1};
        % 直角O-C1-C2
        \draw (O) -- (C1) --(C2) pic [fill=lightgray, angle radius=0.9mm] {right angle = O--C1--C2};
        % 直角C1-H2-C2
        \draw (C1) -- (H2) -- (C2) pic [fill=lightgray, angle radius=0.75mm] {right angle = C1--H2--C2};

        % C1からC2を結ぶ円弧
        \draw[magenta, thick] (C1) arc (30:40:1cm) node [midway,sloped, below] {$d\theta$};

        % C1からH2の高さを表すベクトル
        \draw[->, -Straight Barb, semithick] ($(C1)+ (0.05, 0)$) -- ($(H2)+(0.05,0)$) node [midway, right] {$d\theta\cos \theta$};

        % sin\thetaを表すベクトル
        \draw [<->, Straight Barb-, semithick, shorten <=0.1em] to ($(C1)+(0.05,0)$) -- ($(H)+(0.05,0)$) node [midway, right] { $\sin \theta$ };
      \end{tikzpicture}
    }
  \end{minipage}%
  \begin{minipage}{0.5\hsize}
    \centering
    \scalebox{1.5}{
      \begin{tikzpicture}[scale=3]
        \coordinate (O) at (0,0);
        \coordinate (C1) at (30:1cm);
        \coordinate (C2) at (40:1cm);
        \coordinate (H) at (C1 |- O);
        % Hのx座標とC2のy座標を持つ点
        \coordinate (H2) at (C2 -| H);

        % 三角形O-H-C1
        \draw[fill=myPurple, opacity=0.6] (O) -- (H) -- (C1) -- cycle;
        % 三角形C1-H-C2
        \draw[fill=myPurple, opacity=0.6] (C2) -- (H2) -- (C1) -- cycle;

        % 角H-O-C1を表す扇形
        \draw (H) -- (O) -- (C1) pic [fill=cyan!50, angle radius=9mm, "$\theta$"] {angle = H--O--C1};
        % 角C1-O-C2を表す扇形
        \draw (C1) -- (O) -- (C2) pic [fill=magenta!40, angle radius=9mm] {angle = C1--O--C2};
        % 角C1-H-C2を表す扇形
        \draw (H2) -- (C1) -- (C2) pic [fill=cyan!60, angle radius=2mm] {angle = H2--C1--C2};

        % 直角O-H-C1
        \draw (O) -- (H) -- (C1) pic [fill=lightgray, angle radius=1.25mm] {right angle = O--H--C1};
        % 直角O-C1-C2
        \draw (O) -- (C1) --(C2) pic [fill=lightgray, angle radius=0.9mm] {right angle = O--C1--C2};
        % 直角C1-H2-C2
        \draw (C1) -- (H2) -- (C2) pic [fill=lightgray, angle radius=0.75mm] {right angle = C1--H2--C2};

        % C1からC2を結ぶ円弧
        \draw[magenta, thick] (C1) arc (30:40:1cm) node [midway,sloped, below] {$d\theta$};

        % C2からH2の幅を表すベクトル
        \draw[<-, Straight Barb-, semithick] ($(C2)+ (0, 0.05)$) -- ($(H2)+(0,0.05)$) node [midway, above] {$d\theta\sin \theta$};

        % cos\thetaを表すベクトル
        \draw [<-, Straight Barb-, semithick] to ($(H)-(0,0.05)$) -- ($(O)-(0,0.05)$) node [midway, below] { $\cos \theta$ };
      \end{tikzpicture}
    }
  \end{minipage}
\end{figure}

\subsubsection{$\sin$の微分}

三角形の高さは、$d\theta\cos\theta$だけ増えているので、

\begin{equation}
  \sin (\theta +d\theta) = \origFn{\sin\theta} + \derivFn{\cos\theta} d\theta
\end{equation}

\begin{theorem}{$\sin$関数の微分}
  \LARGE
  \begin{equation}
    \frac{d}{d\theta}\sin\theta = \cos\theta
  \end{equation}
\end{theorem}

\subsubsection{$\cos$の微分}

三角形の底辺の長さは、$d\theta\sin\theta$だけ減っているので、

\begin{align}
  \cos (\theta +d\theta) & = \cos\theta - \sin\theta d\theta                       \\
  \cos (\theta +d\theta) & = \origFn{\cos\theta} + (\derivFn{-\sin\theta}) d\theta
\end{align}

\begin{theorem}{$\cos$関数の微分}
  \LARGE
  \begin{equation}
    \frac{d}{d\theta}\cos\theta = -\sin\theta
  \end{equation}
\end{theorem}

\subsection{ネイピア数}

指数関数を定義した際に、「どんな数も$0$乗したら$1$になる」と定義した。

つまり、指数関数$y=a^x$において、$x=0$での関数の値は$1$である。

ここでさらに、$x=0$でのグラフの傾きも$1$となるような$a$を探し、その値をネイピア数と呼ぶことにする。

\begin{definition}{ネイピア数（自然対数の底）}
  \titlegap
  指数関数$y=a^x$において、$x=0$での接線の傾きが$1$となるような底$a$の値をネイピア数と呼び、$e$と表す。
\end{definition}

この定義では、「$x=0$では関数の値も傾きも等しく$1$になる」という、$x=0$での振る舞いにしか言及していない。

だが、実はネイピア数を底とする指数関数は、「微分しても変わらない（すべての$x$において、関数の値と傾きが一致する）」という性質を持つ。

\subsection{ネイピア数を底とする指数関数の微分}

指数関数$y=e^x$の微分は、導関数の定義から次のように計算できる。

\begin{align}
  \dfrac{d}{dx}e^x & = \lim_{\Delta x \to 0} \dfrac{e^{x+\Delta x} - e^x}{\Delta x}         \\
                   & = \lim_{\Delta x \to 0} \dfrac{e^x \cdot e^{\Delta x} - e^x}{\Delta x} \\
                   & = \lim_{\Delta x \to 0} \dfrac{e^x \cdot (e^{\Delta x} - 1)}{\Delta x} \\
                   & = e^x \cdot \lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x}
\end{align}

ここで、$\displaystyle\lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x}$は$x$によらない定数であり、

\begin{align}
  \lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x} & = \lim_{\Delta x \to 0} \dfrac{e^{0 + \Delta x} - e^0}{\Delta x}
\end{align}

というように、これは$x=0$における傾き（導関数に$x=0$を代入したもの）を表している。

そもそも、ネイピア数$e$の定義は「$x=0$での$e^x$の傾きが$1$」というものだったので、

\begin{equation}
  \lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x} = 1
\end{equation}

となり、「$e^x$は微分しても変わらない」という性質が導かれる。

\begin{equation}
  \dfrac{d}{dx}e^x = e^x
\end{equation}

\begin{theorem}{ネイピア数を底とする指数関数の微分}
  \titlegap
  ネイピア数を底とする指数関数は、微分しても変わらない関数である。
  \LARGE
  \begin{equation}
    \dfrac{d}{dx}e^x = e^x
  \end{equation}
\end{theorem}

\subsubsection{指数が定数倍されている場合}

$y = e^{kx}$のように、指数が定数倍（$k$倍）されている場合は、合成関数の微分の公式を使って計算できる。

$t=kx$とおくと、

\begin{align}
  \dfrac{dy}{dx} & = \dfrac{dt}{dx} \cdot \dfrac{dy}{dt}          \\
                 & = \dfrac{d}{dx} (kx) \cdot \dfrac{d}{dt} (e^t) \\
                 & = k\dfrac{\cancel{dx}}{\cancel{dx}} \cdot e^t  \\
                 & = ke^{t}                                       \\
                 & = ke^{kx}
\end{align}

となり、$e^{kx}$自体は変わらず、指数の係数$k$が$e$の肩から「降りてくる」形になる。

\begin{theorem}{ネイピア数を底とする指数関数の微分（指数が定数倍されている場合）}
  \titlegap
  $k$を定数とし、指数が$k$倍されている場合は、微分すると全体が$k$倍される。
  \LARGE
  \begin{equation}
    \dfrac{d}{dx}e^{kx} = ke^{kx}
  \end{equation}
\end{theorem}

\subsubsection{指数が関数の場合}

指数が関数になっている場合$y=e^{f(x)}$の微分も、合成関数の微分を使って考えればよい。

$t=f(x)$とおくと、

\begin{align}
  \dfrac{dy}{dx} & = \dfrac{dy}{dt} \cdot \dfrac{dt}{dx}      \\
                 & = \dfrac{d}{dt}e^t \cdot \dfrac{d}{dx}f(x) \\
                 & = e^t \cdot f'(x)                          \\
                 & = e^{f(x)} \cdot f'(x)
\end{align}

\begin{theorem}{ネイピア数を底とする指数関数の微分（指数が関数の場合）}
  \LARGE
  \begin{equation}
    \dfrac{d}{dx}e^{f(x)} = f'(x)e^{f(x)}
  \end{equation}
\end{theorem}

\subsection{一般の指数関数の微分}

指数関数の底の変換公式より、$a$を底とする指数関数の微分は、ネイピア数$e$を底とする指数関数の微分（指数が定数倍されている場合）に帰着できる。

\begin{review}
  指数関数の底の変換公式
  \begin{equation}
    a^x = b^{(\log_b a)x}
  \end{equation}
\end{review}

指数関数の底の変換公式において、$b=e$の場合を考えると、

\begin{equation}
  a^x = e^{(\log a)x}
\end{equation}

となるので、指数が$\log a$倍された、$e$を底とする指数関数の微分として考えればよい。

\begin{equation}
  \begin{WithArrows}
    \dfrac{d}{dx} a^x &= \dfrac{d}{dx} e^{(\log a)x} \Arrow{$\dfrac{d}{dx}e^{kx} = ke^{kx}$} \\
    &= (\log a)e^{(\log a)x} \Arrow{$e^{(\log a)x} = a^x$} \\
    &= (\log a)a^x
  \end{WithArrows}
\end{equation}

\begin{theorem}{指数関数の微分}
  \LARGE
  \begin{equation}
    \dfrac{d}{dx} a^x = a^x(\log a)
  \end{equation}
\end{theorem}

\subsection{対数関数の微分}

\subsubsection{自然対数の微分（底がネイピア数の対数の微分）}

底がネイピア数である対数は、自然対数と呼ばれる。

\begin{definition}{自然対数}
  \titlegap
  底がネイピア数$e$である対数関数を\hl{自然対数}といい、次のように底$e$を省略して表記する。
  \LARGE
  \begin{equation}
    \log x
  \end{equation}
\end{definition}

$y=\log x$は$x=e^y$の逆関数であるから、$e^y$の微分$e^y$の逆数を考えればよい。

\begin{equation}
  \dfrac{d}{dx}\log x = \dfrac{1}{e^y} = \dfrac{1}{x}
\end{equation}

\begin{theorem}{自然対数の微分}
  \LARGE
  \begin{equation}
    \dfrac{d}{dx}\log x = \dfrac{1}{x}
  \end{equation}
\end{theorem}

\subsection{対数微分法}

\subsubsection{真数が関数である自然対数の微分}

$y=\log f(x)$の微分は、対数微分法と呼ばれる微分テクニックの原理となる。

この微分は、$t=f(x)$として合成関数の微分を考えることで計算できる。

\begin{align}
  \dfrac{d}{dx}\log f(x) & = \dfrac{dy}{dt} \cdot \dfrac{dt}{dx}         \\
                         & = \dfrac{d}{dt}\log t \cdot \dfrac{d}{dx}f(x) \\
                         & = \dfrac{1}{t} \cdot f'(x)                    \\
                         & = \dfrac{1}{f(x)} \cdot f'(x)                 \\
                         & = \dfrac{f'(x)}{f(x)}
\end{align}

\begin{theorem}{真数が関数である自然対数の微分}
  \LARGE
  \begin{equation}
    \dfrac{d}{dx}\log f(x) = \dfrac{f'(x)}{f(x)}
  \end{equation}
\end{theorem}

ここで、この式を$f'(x) = \ldots$の形に直してみよう。

\begin{align}
  f'(x) = f(x) \cdot \dfrac{d}{dx}\log f(x)
\end{align}

関数$f(x)$の微分$f'(x)$は、$\log$を取ってから微分したもの$\dfrac{d}{dx}\log f(x)$に、元の関数$f(x)$をかけることでも計算できることがわかる。

\begin{theorem}{対数微分法の原理}
  \titlegap
  $\log$を取ってから微分したものに元の関数をかける操作は、微分することと同じになる。
  \LARGE
  \begin{equation}
    f'(x) = f(x) \cdot \left(\log f(x)\right)'
  \end{equation}
\end{theorem}

この原理によって、$f(x)$の微分計算を、$\log f(x)$の微分計算に置き換えることが可能になる。

対数を取ることで、対数の性質が使えるようになるため、微分が簡単になることがある。そんなときにこの原理が役に立つ。

\subsubsection{対数微分法でライプニッツ則（関数の積の微分）を導く}

$f(x)g(x)$の微分を、対数経由で計算してみよう。

\vskip\baselineskip

まず、$\log (f(x)g(x))$の微分は、「積の対数が対数の和になる」という対数の性質を用いて、次のように計算できる。

\begin{align}
  \dfrac{d}{dx} \log (f(x)g(x)) & = \dfrac{d}{dx} \left(\log f(x) + \log g(x)\right)  \\
                                & = \dfrac{d}{dx} \log f(x) + \dfrac{d}{dx} \log g(x) \\
                                & = \dfrac{f'(x)}{f(x)} + \dfrac{g'(x)}{g(x)}         \\
                                & = \dfrac{f'(x)g(x) + f(x)g'(x)}{f(x)g(x)}
\end{align}

対数微分法の原理より、この式に$f(x)g(x)$をかけたものが、$f(x)g(x)$の微分になる。

\begin{align}
  (f(x)g(x))' & = f(x)g(x) \cdot \dfrac{d}{dx} \log (f(x)g(x))                             \\
              & = \cancel{f(x)g(x)} \cdot \dfrac{f'(x)g(x) + f(x)g'(x)}{\cancel{f(x)g(x)}} \\
              & = f'(x)g(x) + f(x)g'(x)
\end{align}

これは、関数の積の微分公式である、ライプニッツ則の式に一致している。

\subsubsection{対数微分法で分数関数の微分（関数の商の微分）を考える}

続いて、$\dfrac{f(x)}{g(x)}$の微分も対数微分法で計算してみよう。

\vskip\baselineskip

$\log \dfrac{f(x)}{g(x)}$の微分は、「商の対数が対数の差になる」という対数の性質を用いて、次のように計算できる。

\begin{align}
  \dfrac{d}{dx} \log \dfrac{f(x)}{g(x)} & = \dfrac{d}{dx} \left(\log f(x) - \log g(x)\right)  \\
                                        & = \dfrac{d}{dx} \log f(x) - \dfrac{d}{dx} \log g(x) \\
                                        & = \dfrac{f'(x)}{f(x)} - \dfrac{g'(x)}{g(x)}         \\
                                        & = \dfrac{f'(x)g(x) - f(x)g'(x)}{f(x)g(x)}
\end{align}

対数微分法の原理より、この式に$\dfrac{f(x)}{g(x)}$をかけたものが、$\dfrac{f(x)}{g(x)}$の微分になる。

\begin{align}
  \left(\dfrac{f(x)}{g(x)}\right)' & = \dfrac{f(x)}{g(x)} \cdot \dfrac{d}{dx} \log \dfrac{f(x)}{g(x)}                     \\
                                   & = \dfrac{\cancel{f(x)}}{g(x)} \cdot \dfrac{f'(x)g(x) - f(x)g'(x)}{\cancel{f(x)}g(x)} \\
                                   & = \dfrac{f'(x)g(x) - f(x)g'(x)}{(g(x))^2}
\end{align}

\begin{theorem}{分数関数の微分}
  \LARGE
  \begin{equation}
    \left(\dfrac{f(x)}{g(x)}\right)' = \dfrac{f'(x)g(x) - f(x)g'(x)}{(g(x))^2}
  \end{equation}
\end{theorem}

\subsubsection{関数の積・商の微分の比較}

対数を取ってから微分すると、ライプニッツ則と分数関数の微分の違いがシンプルに表現される。

\begin{alignat}{3}
   & \dfrac{d}{dx} \log \left(f(x)g(x)\right) & = \dfrac{f'(x)}{f(x)} + \dfrac{g'(x)}{g(x)} \\
   & \dfrac{d}{dx} \log \dfrac{f(x)}{g(x)}    & = \dfrac{f'(x)}{f(x)} - \dfrac{g'(x)}{g(x)}
\end{alignat}

あとは、これらに$f(x)g(x)$や$\dfrac{f(x)}{g(x)}$をかけることで、元の関数の微分の式が導ける。

\end{document}