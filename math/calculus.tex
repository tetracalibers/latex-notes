\documentclass[../math-imaging]{subfiles}

\begin{document}

\chapter{微分と積分}

\section{1変数関数の微分}

微分とは、複雑な問題も「拡大して見たら簡単に見える（かもしれない）」という発想で、わずかな変化に着目して入力と出力の関係（関数）を調べる手法といえる。

\subsection{接線：拡大したら直線に近似できる}

関数$y=f(x)$について、引数の値を$x=x_0$からわずかに増加させて、$x=x_0+\Delta x$にした場合の出力の変化を考える。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{1.5};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0) [below, scale=0.5]{$\strut x_0 + \Delta x$};
      \node (X1) at (\xi,0) [below, scale=0.5, baseline = (X2.base)]{$\strut x_0$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x_0)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x_0 + \Delta x)$};

      % x軸からの補助線
      \draw[auxline, thin, lightgray] (\xi,0) -- (A);
      \draw[auxline, thin, lightgray] (\xj,0) -- (B);

      % y軸からの補助線
      \draw[auxline, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[auxline, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % \Delta xを表す矢印
      \draw[<->] ($(A)-(0,0.1)$) -- ($(B)-(0,0.1)$) node [midway, below]{$\Delta x$};
    \end{tikzpicture}
  }
\end{center}

このとき、増分の幅$\Delta x$を狭くしていく（$\Delta x$の値を小さくしていく）と、$x=x_0$付近において、関数$y=f(x)$のグラフは直線にほとんど重なるようになる。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}[spy using outlines={circle, magnification=4, size=2cm, connect spies}]
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{0.95};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % x軸からの補助線
      \draw[dotted, thin, lightgray] (\xi,0) -- (A);
      \draw[dotted, thin, lightgray] (\xj,0) -- (B);
      % y軸からの補助線
      \draw[dotted, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[dotted, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0) [below right, scale=0.5]{$\strut x_0 + \Delta x$};
      \node (X1) at (\xi,0) [below, scale=0.5, baseline = (X2.base)]{$\strut x_0$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x_0)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x_0 + \Delta x)$};

      \spy [Aquamarine] on ($(A)!.5!(C)$) in node [left] at (3.5,-1.25);
    \end{tikzpicture}
  }
\end{center}

このように、関数$f(x)$は、ある点$x_0$の付近では、

\begin{equation}
  f(x) \simeq a(x - x_0) +b
\end{equation}

という直線に近似することができる。

\vskip\baselineskip

ここで、$f(x_0)$の値を考えると、

\begin{align}
  f(x_0) & = a(x_0 - x_0) + b \\
         & = a\cdot 0 + b     \\
         & = b
\end{align}

であるから、実は$b=f(x_0)$である。

\vskip\baselineskip

一方、$a$はこの直線の傾きを表す。

そもそも、傾きとは、$x$が増加したとき、$y$がどれだけ急に（速く）増加するかを表す量である。

関数のグラフを見ると、急激に上下する箇所もあれば、なだらかに変化する箇所もある。

つまり、ある点でグラフにぴったりと沿う直線（接線）を見つけたとしても、その傾きは場所によって異なる。

そこで、「傾きは位置$x$の関数」とみなして、次のように表現しよう。

\begin{equation}
  a = f'(x)
\end{equation}

これで、先ほどの直線の式を完成させることができる。

\begin{theorem}{関数の各点の接線}
  \newline
  関数$f(x)$は、ある点$x_0$の付近では、
  \Large
  \begin{equation}
    f(x) \simeq f(x_0) + f'(x)(x - x_0)
  \end{equation}
  \normalsize
  という傾き$f'(x)$の直線に近似できる。
\end{theorem}

\subsection{接線の傾きとしての導関数}

傾きは位置$x$の関数$f'(x)$としたが、この関数がどのような関数なのか、結局傾きを計算する方法がわかっていない。

直線の傾きは$x$と$y$の増加率の比として定義されているから、まずはそれぞれの増加率を数式で表現しよう。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{1.5};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0) [below, scale=0.5]{$\strut x + \Delta x$};
      \node (X1) at (\xi,0) [below, scale=0.5, baseline = (X2.base)]{$\strut x$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x + \Delta x)$};

      % x軸からの補助線
      \draw[auxline, thin, lightgray] (\xi,0) -- (A);
      \draw[auxline, thin, lightgray] (\xj,0) -- (B);

      % y軸からの補助線
      \draw[auxline, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[auxline, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % \Delta xを表す矢印
      \draw[<->] ($(A)-(0,0.1)$) -- ($(B)-(0,0.1)$) node [midway, below]{$\Delta x$};
      % \Delta yを表す矢印
      \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
    \end{tikzpicture}
  }
\end{center}

この図から、$y$の増加率$\Delta y$は次のように表せることがわかる。

\begin{equation}
  \Delta y = f(x + \Delta x) - f(x)
\end{equation}

この両辺を$\Delta x$で割ると、$x$の増加率$\Delta x$と$y$の増加率$\Delta y$の比率が表せる。

\begin{equation}
  \frac{\Delta y}{\Delta x} = \frac{f(x + \Delta x) - f(x)}{\Delta x}
\end{equation}

図では$\Delta x$には幅があるが、この幅を限りなく$0$に近づけると、幅というより点になる。

つまり、$\Delta x \rightarrow 0$とすれば、$\dfrac{\Delta y}{\Delta x}$は任意の点$x$での接線の傾きとなる。

「任意の点$x$での傾き」も$x$の関数であり、この関数を導関数と呼ぶ。

\begin{definition}{導関数}
  \newline
  関数$f(x)$の任意の点$x$における接線の傾き（増加の速さ）を表す関数を導関数といい、次のように定義する。
  \Large
  \begin{equation}
    f'(x) = \lim_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}
  \end{equation}
\end{definition}

\subsection{微分とその関係式}

\begin{definition}{微分}
  関数$f(x)$から、その導関数$f'(x)$を求める操作を微分という。
\end{definition}

関数のグラフから離れて、微分という「計算」を考えるにあたって、先ほどの導関数の定義式よりも都合の良い表現式がある。

$x \to 0$とした後の$\Delta x$を$dx$と書くことにして、$\displaystyle\lim_{\Delta x \to 0}$を取り払ってしまおう。

\begin{equation}
  \begin{WithArrows}
    f'(x) & = \dfrac{f(x + dx) - f(x)}{dx} \Arrow{両辺$\times dx$} \\
    f'(x)dx & = f(x + dx) - f(x) \Arrow{$f(x)$を移項} \\
    f'(x)dx + f(x) & = f(x + dx)
  \end{WithArrows}
\end{equation}

\begin{theorem}{微分の関係式}
  \Large
  \begin{equation}
    f(x + dx)= f(x) + f'(x)dx
  \end{equation}
\end{theorem}

\subsection{不連続点と微分可能性}

点$x$において連続な関数であれば、幅$\Delta x$を小さくすれば、その間の変化量$\Delta y$も小さくなるはずである。

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}
      \def\xmin{-1};
      \def\xmax{3};
      \def\ymin{-1};
      \def\ymax{3};
      \def\fn#1{exp(0.5*#1) - 0.5};
      \def\dfn#1{0.5*exp(0.5*#1)}; % \fnの導関数
      \def\xi{0.75};
      \def\xj{1};

      % よく使う点の座標
      \coordinate (O) at (0,0);
      \coordinate (A) at (\xi, {\fn{\xi}});
      \coordinate (B) at (\xj, {\fn{\xi}});
      \coordinate (C) at (\xj, {\fn{\xj}});
      \coordinate (D) at (A |- C);

      % 座標軸
      \draw[axis] (\xmin,0) -- (\xmax,0) node [right]{$x$};
      \draw[axis] (0,\ymin) -- (0,\ymax) node [above]{$y$};

      % 原点
      \node at (O) [below left]{$O$};

      % 傾きを表す三角形
      \draw[fill=myPurple, myPurple!80!gray, opacity=0.5] (A) --(B) -- (C) -- cycle;

      \begin{scope}
        \clip (\xmin,\ymin) rectangle (\xmax,\ymax);
        % 接線
        \draw[orange] plot[domain=\xmin:\xmax] (\x,{\fn{\xi} + \dfn{\xi}*(\x-\xi)});
        % グラフ
        \draw[magenta,thick] plot[domain=\xmin:\xmax] (\x,{\fn{\x}});
      \end{scope}

      % x軸上の目盛り
      \node (X2) at (\xj,0.1) [below right, scale=0.5]{$\strut x + \Delta x$};
      \node (X1) at (\xi,0.1) [below, scale=0.5, baseline = (X2.base)]{$\strut x$};

      % y軸上の目盛り
      \node at (0,{\fn{\xi}}) [left, scale=0.5]{$f(x)$};
      \node at (0,{\fn{\xj}}) [left, scale=0.5]{$f(x + \Delta x)$};

      % x軸からの補助線
      \draw[auxline, thin, lightgray] (\xi,0) -- (A);
      \draw[auxline, thin, lightgray] (\xj,0) -- (B);

      % y軸からの補助線
      \draw[auxline, thin, lightgray] (0,{\fn{\xi}}) -- (A);
      \draw[auxline, thin, lightgray] (0,{\fn{\xj}}) --(C);

      % \Delta xを表す矢印
      \draw[<->] ($(A)-(0,0.1)$) -- ($(B)-(0,0.1)$) node [midway, below]{$\Delta x$};
      % \Delta yを表す矢印
      \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
    \end{tikzpicture}
  }
\end{center}

しかし、不連続な点について考える場合は、そうはいかない。

下の図を見ると、$\Delta x$の幅を小さくしても、$\Delta y$は不連続点での関数の値の差の分までしか小さくならない。

\begin{figure}[H]
  \begin{minipage}{0.5\hsize}
    \centering
    \scalebox{1.5}{\begin{tikzpicture}
        \def\xmin{-1};
        \def\xmax{3};
        \def\ymin{-1};
        \def\ymax{3};
        \def\fnA#1{0.5*sin(deg(0.5*pi*#1))+1};
        \def\fnB#1{-0.5*cos(deg(0.5*pi*#1+0.25))+2};
        \def\xi{1};
        \def\xj{1.5};

        % よく使う点の座標
        \coordinate (O) at (0,0);
        \coordinate (A) at (\xi, {\fnA{\xi}});
        \coordinate (B) at (\xj, {\fnB{\xj}});
        \coordinate (C) at (\xj, {\fnA{\xi}});
        \coordinate (D) at (A |- B);

        % 原点
        \node at (O) [below left]{$O$};

        % 座標軸
        \draw[axis] (\xmin,0) -- (\xmax,0) node[right] {$x$};
        \draw[axis] (0,\ymin) -- (0,\ymax) node[above] {$y$};

        % 関数の描画
        \draw[domain=\xmin:\xi, samples=100, magenta,thick, smooth] plot (\x, {\fnA{\x}});
        \draw[domain=\xi:\xmax, samples=100, magenta,thick, smooth] plot (\x, {\fnB{\x}});

        % x軸上の目盛り
        \node (X2) at (\xj,0.15) [below right, scale=0.75]{$\strut x + \Delta x$};
        \node (X1) at (\xi,0.15) [below left, scale=0.75, baseline = (X2.base)]{$\strut x$};

        % y軸上の目盛り
        \node at (0,{\fnA{\xi}}) [left, scale=0.75]{$f(x)$};
        \node at (0,{\fnB{\xj}}) [left, scale=0.75]{$f(x + \Delta x)$};

        % x軸からの補助線
        \draw[auxline, thin, lightgray] (\xi,0) -- (A);
        \draw[auxline, thin, lightgray] (\xj,0) -- (B);

        % y軸からの補助線
        \draw[auxline, thin, lightgray] (0,{\fnA{\xi}}) -- (A);
        \draw[auxline, thin, lightgray] (0,{\fnB{\xj}}) --(B);

        % \Delta xを表す矢印
        \draw[<->] ($(A)-(0,0.1)$) -- ($(C)-(0,0.1)$) node [midway, below]{$\Delta x$};
        % \Delta yを表す矢印
        \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
      \end{tikzpicture}
    }
  \end{minipage}%
  \begin{minipage}{0.5\hsize}
    \centering
    \scalebox{1.5}{
      \begin{tikzpicture}
        \def\xmin{-1};
        \def\xmax{3};
        \def\ymin{-1};
        \def\ymax{3};
        \def\fnA#1{0.5*sin(deg(0.5*pi*#1))+1};
        \def\fnB#1{-0.5*cos(deg(0.5*pi*#1+0.25))+2};
        \def\xi{1};
        \def\xj{1};

        % よく使う点の座標
        \coordinate (O) at (0,0);
        \coordinate (A) at (\xi, {\fnA{\xi}});
        \coordinate (B) at (\xj, {\fnB{\xj}});
        \coordinate (C) at (\xj, {\fnA{\xi}});
        \coordinate (D) at (A |- B);

        % 原点
        \node at (O) [below left]{$O$};

        % 座標軸
        \draw[axis] (\xmin,0) -- (\xmax,0) node[right] {$x$};
        \draw[axis] (0,\ymin) -- (0,\ymax) node[above] {$y$};

        % 関数の描画
        \draw[domain=\xmin:\xi, samples=100, magenta,thick, smooth] plot (\x, {\fnA{\x}});
        \draw[domain=\xi:\xmax, samples=100, magenta,thick, smooth] plot (\x, {\fnB{\x}});

        % x軸上の目盛り
        \node (X2) at (\xj,0) [below, scale=0.6]{$ (x+ \Delta x) \simeq x$};

        % y軸上の目盛り
        \node at (0,{\fnA{\xi}}) [left, scale=0.75]{$f(x)$};
        \node at (0,{\fnB{\xj}}) [left, scale=0.75]{$f(x + \Delta x)$};

        % x軸からの補助線
        \draw[auxline, thin, lightgray] (\xi,0) -- (A);
        \draw[auxline, thin, lightgray] (\xj,0) -- (B);

        % y軸からの補助線
        \draw[auxline, thin, lightgray] (0,{\fnA{\xi}}) -- (A);
        \draw[auxline, thin, lightgray] (0,{\fnB{\xj}}) --(B);

        % \Delta xを表す矢印
        \draw ($(A)-(0,0.1)$) -- ($(C)-(0,0.1)$) node [midway, below]{$\Delta x$};
        % \Delta yを表す矢印
        \draw[<->] ($(A)+(-0.1,0)$) -- ($(D)+(-0.1, 0)$) node [midway, left]{$\Delta y$};
      \end{tikzpicture}
    }
  \end{minipage}
\end{figure}

このような不連続点においては、どんなに拡大しても、関数のグラフが直線にぴったりと重なることはない。

「拡大すれば直線に近似できる」というのが微分の考え方だが、不連続点ではこの考え方を適用できないのだ。

\vskip\baselineskip

関数の不連続点においては、微分という計算を考えることがそもそもできない。

ある点での関数のグラフが直線に重なる（微分可能である）ためには、$\Delta x \to 0$としたときに$\Delta y \to 0$となる必要がある。

\subsection{導関数のさまざまな記法}

微分を考えるときは、$\Delta x \to 0$としたときに$\Delta y \to 0$となる前提のもとで議論する。

$\Delta x \to 0$とした結果を$dx$、$\Delta y \to 0$の結果を$dy$とすると、ある点$x$での接線の傾きは、次のようにも表現できる。

\begin{equation}
  \frac{dy}{dx} = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}
\end{equation}

この接線の傾きが$x$の関数であることを表現したいときは、次のように書くこともある。

\begin{equation}
  \dfrac{dy}{dx}(x)
\end{equation}

これも一つの導関数（位置に応じた接線の傾きを表す関数）の表記法である。

この記法は、どの変数で微分しているかがわかりやすいという利点がある。

\begin{definition}{導関数のライプニッツ記法}
  \newline
  次のような記号はいずれも、関数$y = f(x)$の導関数を表す。
  \Large
  \begin{equation}
    \frac{dy}{dx} = \dfrac{dy}{dx}(x) = \dfrac{df}{dx} = \dfrac{d}{dx}f(x)
  \end{equation}
\end{definition}

特に、$\dfrac{d}{dx}f(x)$という記法は、$\dfrac{d}{dx}$の部分を微分操作を表す演算子として捉えて、「関数$f(x)$に微分という操作を施した」ことを表現しているように見える。

\begin{definition}{微分演算子}
  \newline
  関数を微分するという操作を表現する演算子を微分演算子という。\\
  例えば、次のような記号で表される。
  \Large
  \begin{equation}
    \dfrac{d}{dx}
  \end{equation}
\end{definition}

ところで、これまで使ってきた$f'(x)$という導関数の記法にも、名前がついている。

\begin{definition}{導関数のニュートン記法}
  \newline
  次の記号は、関数$y = f(x)$の導関数を表す。
  \Large
  \begin{equation}
    f'(x)
  \end{equation}
\end{definition}

この記法は、「$f$という関数から導出された関数が$f'$である」ことを表現している。

導関数はあくまでも関数$f$から派生したものであるから、$f$という文字はそのまま、加工されたことを表すために$'$をつけたものと解釈できる。

\subsection{微分の性質}

微分の関係式を使うことで、微分に関する有用な性質を導くことができる。

\begin{review}
  微分の関係式
  \begin{equation}
    f(x + dx)= \origFn{f(x)} + \derivFn{f'(x)} dx
  \end{equation}
\end{review}

\subsubsection{関数の一次結合の微分}

$\alpha f(x) + \beta g(x)$において、$x$を$dx$だけ微小変化させてみる。
\begin{align}
  \alpha f(x+dx) + \beta g(x+dx)
   & = \alpha \left\{ f(x) + f'(x) dx \right\} + \beta \left\{ g(x) + g'(x) dx \right\}    \\
   & = \origFn{ \alpha f(x) + \beta g(x) }+ \{ \derivFn{ \alpha f'(x) + \beta g'(x)} \} dx
\end{align}

\begin{theorem}{微分の線形性}
  \Large
  \begin{equation}
    \left( \alpha f(x) + \beta g(x) \right)' = \alpha f'(x) + \beta g'(x)
  \end{equation}
\end{theorem}

\subsubsection{関数の積の微分}

$f(x)g(x)$において、$x$を$dx$だけ微小変化させてみる。

\begin{align}
  f(x+dx)g(x+dx)
   & = \left\{ f(x) + f'(x) dx \right\} \left\{ g(x) + g'(x) dx \right\}                                            \\
   & = f(x)g(x) + f'(x)g(x)dx + f(x)g'(x)dx +  f'(x)g'(x)dx^2                                                       \\
   & = f(x)g(x) + \{ f'(x)g(x) + f(x)g'(x) \}dx + \fitLabelMath[BlueGreen][BlueGreen!40]{ f'(x)g'(x)dx^2}{2次以上の微小量}
\end{align}

ここで、$dx^2$は、$dx$より速く$0$に近づくので無視できる。

荒く言ってしまえば、$dx$でさえ微小量なのだから、$dx^2$なんて存在しないも同然だと考えてよい。

このことは、次の図を見るとイメージできる。

\begin{center}
  \begin{tikzpicture}
    \def\width{6}
    \def\height{4}
    \def\dx{2.25}

    % 座標
    \coordinate (A) at (0,0);
    \coordinate (B) at (\width,0);
    \coordinate (C) at (\width,\height);
    \coordinate (D) at (0,\height);
    \coordinate (Cx) at ($(C)+(\dx,0)$);
    \coordinate (Cy) at ($(C)+(0,\dx)$);
    \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
    \coordinate (Bx) at ($(B)+(\dx,0)$);
    \coordinate (Dy) at ($(D)+(0,\dx)$);

    % % 点（デバッグ用）
    % \fill (A) circle[radius=2pt] node[below left] {A};
    % \fill (B) circle[radius=2pt] node[below right] {B};
    % \fill (C) circle[radius=2pt] node[above right] {C};
    % \fill (D) circle[radius=2pt] node[above left] {D};
    % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
    % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
    % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
    % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
    % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

    % 長方形
    \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$f(x)g(x)$};
    \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx) node[pos=.5] {$f'(x)g(x)dx$};
    \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy) node[pos=.5] {$f(x)g'(x)dx$};
    \draw [fill=BlueGreen!30, draw=BlueGreen!70!gray] (C) rectangle (Cxy) node[pos=.5] {$f'(x)g'(x)dx^2$};

    % 補助線
    \def\l{1} % 補助線の長さ
    \draw[auxline] (B) -- ++(0, -\l) node[below] {$f(x)$};
    \draw[auxline] (Bx) -- ++(0, -\l) node[below] {$f(x+dx)$};
    \draw[auxline] (D) -- ++(-\l, 0) node[left] {$g(x)$};
    \draw[auxline] (Dy) -- ++(-\l, 0) node[left] {$g(x+dx)$};

    % 辺の長さを表す矢印
    \def\s{1em} % 辺と矢印の隙間
    \def\h{0.1} % 矢印の矢同士の隙間
    \draw[<->, thick, gray] ($(A)+(\h,-\s)$) -- ($(B)-(\h,\s)$) node[midway,below] {$f(x)$};
    \draw[<->, thick, gray] ($(A)+(-\s,\h)$) -- ($(D)-(\s,\h)$) node[midway,left] {$g(x)$};
    \draw[<->, thick, magenta!80] ($(B)+(\h,-\s)$) -- ($(Bx)-(\h,\s)$) node[midway,below] {$f'(x)dx$};
    \draw[<->, thick, magenta!80] ($(D)+(-\s,\h)$) -- ($(Dy)-(\s,\h)$) node[midway,left] {$g'(x)dx$};
  \end{tikzpicture}
\end{center}

$dx \to 0$のとき$dy \to 0$となる場合に微分という計算を定義するのだから、$dx$を小さくしていくと、$dy$にあたる$f(x + dx) - f(x)$（これは$f'(x)dx$と等しい）も小さくなっていく。

同様にして、$g(x + dx) - g(x)$（これは$g'(x)dx$と等しい）も小さくなっていく。

\begin{review}
  微分の関係式$f(x + dx)= f(x) + f'(x) dx$より、
  \large
  \begin{equation}
    \textcolor{magenta!80}{f'(x)dx} = f(x + dx) - f(x)
  \end{equation}
\end{review}

$dx$を小さくした場合を図示すると、

\begin{center}
  \begin{tikzpicture}
    \def\width{6}
    \def\height{4}
    \def\dx{0.15}

    % 座標
    \coordinate (A) at (0,0);
    \coordinate (B) at (\width,0);
    \coordinate (C) at (\width,\height);
    \coordinate (D) at (0,\height);
    \coordinate (Cx) at ($(C)+(\dx,0)$);
    \coordinate (Cy) at ($(C)+(0,\dx)$);
    \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
    \coordinate (Bx) at ($(B)+(\dx,0)$);
    \coordinate (Dy) at ($(D)+(0,\dx)$);

    % % 点（デバッグ用）
    % \fill (A) circle[radius=2pt] node[below left] {A};
    % \fill (B) circle[radius=2pt] node[below right] {B};
    % \fill (C) circle[radius=2pt] node[above right] {C};
    % \fill (D) circle[radius=2pt] node[above left] {D};
    % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
    % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
    % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
    % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
    % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

    % 長方形
    \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$f(x)g(x)$};
    \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx);
    \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy);
    \draw [fill=BlueGreen!40, draw=BlueGreen!70!gray] (C) rectangle (Cxy);
  \end{tikzpicture}
\end{center}

$\fitLabelMath[BlueGreen][BlueGreen!40]{f'(x)g'(x)dx^2}{\footnotesize 2次以上の微小量}$に相当する左上の領域は、ほとんど点になってしまうことがわかる。

\vskip\baselineskip

このように、$dx^2$の項は無視してもよいものとして、先ほどの計算式は次のようになる。

\begin{align}
  f(x+dx)g(x+dx)
   & = \origFn{f(x)g(x)} + \{ \derivFn{f'(x)g(x) + f(x)g'(x)} \}dx
\end{align}

\begin{theorem}{微分のライプニッツ則}
  \Large
  \begin{equation}
    \left( f(x) g(x) \right)' = f'(x) g(x) + f(x) g'(x)
  \end{equation}
\end{theorem}

\subsection{冪関数の微分}

具体的な関数の導関数も、微分の関係式をもとに考えることができる。

まずは、簡単な例として、冪関数$y=x^n$の微分を考えてみよう。

\subsubsection{$y=x^2$の微分}

$y=f(x)=x^2$において、$x$を$dx$だけ微小変化させると、$y$は$dy$だけ変化するとする。

すると、微分の関係式は$y + dy = f(x + dx) = (x+dx)^2$となるが、これを次のように展開して考える。

\begin{equation}
  y + dy = (x + dx)(x + dx)
\end{equation}

右辺の$(x+dx)(x+dx)$からは、

\begin{itemize}
  \item $x^2$の項が1つ
  \item $xdx$の項が2つ
  \item $dx^2$の項が1つ
\end{itemize}

現れることになる。

数式で表すと、

\begin{equation}
  \eqnmarkbox[magenta]{Y1}{y} + dy = \eqnmarkbox[magenta]{Y2}{x^2} + 2xdx + dx^2
\end{equation}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

ここで$y=x^2$なので、左辺の$y$と右辺の$x^2$は相殺される。

\begin{equation}
  dy = 2xdx + \fitLabelMath[BlueGreen][BlueGreen!40]{dx^2}{高次の微小量}
\end{equation}

さらに、$dx^2$の項は無視することができる。

なぜなら、$dx$を小さくすると、$dx^2$は$dx$とは比べ物にならないくらい小さくなってしまうからだ。

\begin{center}
  \begin{tikzpicture}
    \begin{scope}[local bounding box=left]
      \def\width{4}
      \def\dx{0.6}

      % 座標
      \coordinate (A) at (0,0);
      \coordinate (B) at (\width,0);
      \coordinate (C) at (\width,\width);
      \coordinate (D) at (0,\width);
      \coordinate (Cx) at ($(C)+(\dx,0)$);
      \coordinate (Cy) at ($(C)+(0,\dx)$);
      \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
      \coordinate (Bx) at ($(B)+(\dx,0)$);
      \coordinate (Dy) at ($(D)+(0,\dx)$);

      % % 点（デバッグ用）
      % \fill (A) circle[radius=2pt] node[below left] {A};
      % \fill (B) circle[radius=2pt] node[below right] {B};
      % \fill (C) circle[radius=2pt] node[above right] {C};
      % \fill (D) circle[radius=2pt] node[above left] {D};
      % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
      % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
      % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

      % 長方形
      \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$x^2$};
      \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx) node[pos=.5, rotate=-90] {$xdx$};
      \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy) node[pos=.5] {$xdx$};
      \draw [fill=BlueGreen!30, draw=BlueGreen!70!gray] (C) rectangle (Cxy) node[pos=.5] {$dx^2$};

      % 辺の長さを表す矢印
      \def\s{1em} % 辺と矢印の隙間
      \def\h{0.01} % 矢印の矢同士の隙間
      \draw[<->, thick, gray] ($(A)+(\h,-\s)$) -- ($(B)-(\h,\s)$) node[midway,below] {$x$};
      \draw[<->, thick, gray] ($(A)+(-\s,\h)$) -- ($(D)-(\s,\h)$) node[midway,left] {$x$};
      \draw[<->, thick, magenta!80] ($(B)+(\h,-\s)$) -- ($(Bx)-(\h,\s)$) node[midway,below] {$dx$};
      \draw[<->, thick, magenta!80] ($(D)+(-\s,\h)$) -- ($(Dy)-(\s,\h)$) node[midway,left] {$dx$};
    \end{scope}

    \begin{scope}[xshift=0.5\textwidth, local bounding box=right]
      \def\width{4}
      \def\dx{0.1}

      % 座標
      \coordinate (A) at (0,0);
      \coordinate (B) at (\width,0);
      \coordinate (C) at (\width,\width);
      \coordinate (D) at (0,\width);
      \coordinate (Cx) at ($(C)+(\dx,0)$);
      \coordinate (Cy) at ($(C)+(0,\dx)$);
      \coordinate (Cxy) at ($(C)+(\dx,\dx)$);
      \coordinate (Bx) at ($(B)+(\dx,0)$);
      \coordinate (Dy) at ($(D)+(0,\dx)$);

      % % 点（デバッグ用）
      % \fill (A) circle[radius=2pt] node[below left] {A};
      % \fill (B) circle[radius=2pt] node[below right] {B};
      % \fill (C) circle[radius=2pt] node[above right] {C};
      % \fill (D) circle[radius=2pt] node[above left] {D};
      % \fill (Cx) circle[radius=2pt] node[above right] {Cx};
      % \fill (Cy) circle[radius=2pt] node[above right] {Cy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Bx) circle[radius=2pt] node[below right] {Bx};
      % \fill (Dy) circle[radius=2pt] node[above left] {Dy};

      % 長方形
      \draw [fill=lightgray!20, draw=lightgray!80!gray] (A) rectangle (C) node[pos=.5] {$x^2$};
      \draw [fill=magenta!30, draw=magenta!70!gray] (B) rectangle (Cx);
      \draw [fill=magenta!30, draw=magenta!70!gray] (D) rectangle (Cy);
      \draw [fill=BlueGreen!30, draw=BlueGreen!70!gray] (C) rectangle (Cxy);
    \end{scope}

    \draw[->, thick] ($(left.east)+(1em, 0)$) -- ($(left-|right.west)-(1em,0)$) node[pos=.5, above] {$dx \to 0$};
  \end{tikzpicture}
\end{center}

というわけで、次のような式が得られる。

\begin{equation}
  dy = 2xdx
\end{equation}

よって、$y=x^2$の導関数は、$y'=2x$となることがわかった。

\begin{equation}
  \frac{dy}{dx} = 2x
\end{equation}

\subsubsection{$y=x^3$の微分}

同じように、$y=x^3$の微分を考えてみよう。

\begin{equation}
  y + dy = (x + dx)(x + dx)(x + dx)
\end{equation}

右辺の$(x+dx)(x+dx)(x+dx)$からは、

\begin{itemize}
  \item $x^3$の項が1つ
  \item $x^2dx$の項が3つ
  \item $dx^3$の項が1つ
\end{itemize}

現れることになる。

\begin{equation}
  \eqnmarkbox[magenta]{Y1}{y} + dy = \eqnmarkbox[magenta]{Y2}{x^3} + 3x^2dx + dx^3
\end{equation}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

ここで$y=x^3$なので、左辺の$y$と右辺の$x^3$は相殺される。

\begin{equation}
  dy = 3x^2dx + \fitLabelMath[BlueGreen][BlueGreen!40]{dx^3}{高次の微小量}
\end{equation}

さらにここでは、$dx^3$の項を無視することができる。

次の図を見てみよう。

各辺$dx$の立方体は、$dx$を小さくすると、ほぼ点にしか見えないほど小さくなる。

つまり、各辺$dx$の立方体の体積$dx^3$は、考慮する必要がない。

\begin{center}
  \tdplotsetmaincoords{60}{125}
  \begin{tikzpicture}[
      tdplot_main_coords,
      grid/.style={very thin,gray},
      axis/.style={->,blue,thick},
      cube/.style={very thick,fill=lightgray!20, draw=lightgray!80!gray},
      cube_dx/.style={very thick,fill=magenta!30, draw=magenta!70!gray, opacity=0.6},
      cube_dx3/.style={very thick,fill=BlueGreen!30, draw=BlueGreen!70!gray, opacity=0.6},
      cube hidden/.style={thick, dashed, draw=lightgray!80!gray}
    ]
    \begin{scope}[local bounding box=left]
      \def\size{3}
      \def\dx{0.6}

      % 頂点の座標
      \coordinate (O) at (0,0,0);
      \coordinate (Axy) at (\size, 0, 0);
      \coordinate (Bxy) at (\size, \size, 0);
      \coordinate (Cxy) at (0, \size, 0);
      \coordinate (Ayz) at (0, 0, \size);
      \coordinate (Byz) at (0, \size, \size);
      \coordinate (Axz) at (\size, 0, \size);
      \coordinate (Axyz) at (\size, \size, \size);

      %%% 元の立方体
      % draw the front-right of the cube
      \draw[cube] (Axy) -- (Bxy) -- (Axyz) -- (Axz) -- cycle;
      % draw the front-left of the cube
      \draw[cube] (Cxy) -- (Bxy) -- (Axyz) -- (Byz) -- cycle;
      % draw the top of the cube
      \draw[cube] (Ayz) -- (Byz) -- (Axyz) -- (Axz) -- cycle;

      %%% x軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- (Bxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Axz) -- (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- (Bxy) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- cycle;
      % 上面
      \draw[cube_dx] (Axz) -- ($(Axz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;

      %%% y軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Bxy) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- (Cxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Cxy) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- (Bxy) -- cycle;
      % 上面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- cycle;

      %%% z軸方向にdxだけ拡張
      % 後ろの面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- (Byz) -- cycle;
      % 左の面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- (Axz) -- cycle;
      % 右の面
      \draw[cube_dx] (Byz) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 前の面
      \draw[cube_dx] (Axz) -- ($(Axz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- cycle;

      %%% 高次の微小量
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(0,\dx,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(0,\dx,0)$) -- cycle; % 底面
      \draw[cube_dx3] ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,0,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle; % 上面

      %%% 辺の長さを表す矢印
      % 辺と矢印の隙間
      \def\s{0.4}
      % dxを表す矢印
      \draw[<->, thick, magenta!80] ($(Axz)+(\s,0,0.15)$) -- ($(Axz)+(\s,0,\dx + 0.15)$) node[midway,left] {$dx$};
      % xを表す矢印
      \draw[<->, thick, gray] ($(Axy)+(\dx + \s,0,0.1)$) -- ($(Axz)+(\dx + \s,0,0.1)$) node[midway,left] {$x$};

      % draw dashed lines to represent hidden edges
      \draw[cube hidden] (O) -- (Axy);
      \draw[cube hidden] (O) -- (Cxy);
      \draw[cube hidden] (O) -- (Ayz);

      % % 座標軸（デバッグ用）
      % \draw[axis] (0,0,0) -- (3,0,0) node[anchor=west]{$x$};
      % \draw[axis] (0,0,0) -- (0,3,0) node[anchor=west]{$y$};
      % \draw[axis] (0,0,0) -- (0,0,3) node[anchor=west]{$z$};
      % % 点（デバッグ用）
      % \fill (O) circle[radius=2pt] node[above left] {O};
      % \fill (Axy) circle[radius=2pt] node[below left] {Axy};
      % \fill (Bxy) circle[radius=2pt] node[below right] {Bxy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Ayz) circle[radius=2pt] node[above left] {Ayz};
      % \fill (Byz) circle[radius=2pt] node[above right] {Byz};
      % \fill (Axz) circle[radius=2pt] node[above left] {Axz};
      % \fill (Axyz) circle[radius=2pt] node[above right] {Axyz};
    \end{scope}

    \begin{scope}[xshift=0.5\textwidth, local bounding box=right]
      \def\size{3}
      \def\dx{0.15}

      % 頂点の座標
      \coordinate (O) at (0,0,0);
      \coordinate (Axy) at (\size, 0, 0);
      \coordinate (Bxy) at (\size, \size, 0);
      \coordinate (Cxy) at (0, \size, 0);
      \coordinate (Ayz) at (0, 0, \size);
      \coordinate (Byz) at (0, \size, \size);
      \coordinate (Axz) at (\size, 0, \size);
      \coordinate (Axyz) at (\size, \size, \size);

      %%% 元の立方体
      % draw the front-right of the cube
      \draw[cube] (Axy) -- (Bxy) -- (Axyz) -- (Axz) -- cycle;
      % draw the front-left of the cube
      \draw[cube] (Cxy) -- (Bxy) -- (Axyz) -- (Byz) -- cycle;
      % draw the top of the cube
      \draw[cube] (Ayz) -- (Byz) -- (Axyz) -- (Axz) -- cycle;

      %%% x軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- (Bxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Axz) -- (Axy) -- ($(Axy)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- (Bxy) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- cycle;
      % 上面
      \draw[cube_dx] (Axz) -- ($(Axz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axy)+(\dx,0,0)$) -- ($(Bxy)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axz)+(\dx,0,0)$) -- cycle;

      %%% y軸方向にdxだけ拡張
      % 底面
      \draw[cube_dx] (Bxy) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- (Cxy) -- cycle;
      % 後ろの面
      \draw[cube_dx] (Cxy) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 前面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- (Bxy) -- cycle;
      % 上面
      \draw[cube_dx] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- (Byz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Axyz)+(0,\dx,0)$) -- ($(Bxy)+(0,\dx,0)$) -- ($(Cxy)+(0,\dx,0)$) -- ($(Byz)+(0,\dx,0)$) -- cycle;

      %%% z軸方向にdxだけ拡張
      % 後ろの面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- (Byz) -- cycle;
      % 左の面
      \draw[cube_dx] (Ayz) -- ($(Ayz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- (Axz) -- cycle;
      % 右の面
      \draw[cube_dx] (Byz) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 前の面
      \draw[cube_dx] (Axz) -- ($(Axz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- (Axyz) -- cycle;
      % 正方形
      \draw[cube_dx] ($(Ayz)+(0,0,\dx)$) -- ($(Byz)+(0,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- ($(Axz)+(0,0,\dx)$) -- cycle;

      %%% 高次の微小量
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(0,\dx,\dx)$) -- ($(Axyz)+(0,0,\dx)$) -- cycle;
      \draw[cube_dx3] (Axyz) -- ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(0,\dx,0)$) -- cycle; % 底面
      \draw[cube_dx3] ($(Axyz)+(\dx,0,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,\dx,0)$) -- ($(Axyz)+(\dx,\dx,0)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle;
      \draw[cube_dx3] ($(Axyz)+(0,0,\dx)$) -- ($(Axyz)+(\dx,0,\dx)$) -- ($(Axyz)+(\dx,\dx,\dx)$) -- ($(Axyz)+(0,\dx,\dx)$) -- cycle; % 上面

      % draw dashed lines to represent hidden edges
      \draw[cube hidden] (O) -- (Axy);
      \draw[cube hidden] (O) -- (Cxy);
      \draw[cube hidden] (O) -- (Ayz);

      % % 座標軸（デバッグ用）
      % \draw[axis] (0,0,0) -- (3,0,0) node[anchor=west]{$x$};
      % \draw[axis] (0,0,0) -- (0,3,0) node[anchor=west]{$y$};
      % \draw[axis] (0,0,0) -- (0,0,3) node[anchor=west]{$z$};
      % % 点（デバッグ用）
      % \fill (O) circle[radius=2pt] node[above left] {O};
      % \fill (Axy) circle[radius=2pt] node[below left] {Axy};
      % \fill (Bxy) circle[radius=2pt] node[below right] {Bxy};
      % \fill (Cxy) circle[radius=2pt] node[above right] {Cxy};
      % \fill (Ayz) circle[radius=2pt] node[above left] {Ayz};
      % \fill (Byz) circle[radius=2pt] node[above right] {Byz};
      % \fill (Axz) circle[radius=2pt] node[above left] {Axz};
      % \fill (Axyz) circle[radius=2pt] node[above right] {Axyz};
    \end{scope}

    \draw[->, thick] ($(left.east)+(1em, 0)$) -- ($(left-|right.west)-(1em,0)$) node[pos=.5, above] {$dx \to 0$};
  \end{tikzpicture}
\end{center}

というわけで、$y=x^3$の導関数は、$y'=3x^2$となることがわかった。

\begin{equation}
  \frac{dy}{dx} = 3x^2
\end{equation}

\subsubsection{$y=x^n$の微分（$n$が自然数の場合）}

$n$が自然数だとすると、$y=x^n$の微分は、$y=x^2$や$y=x^3$の場合と同じように考えられる。

\begin{equation}
  y + dy = \underbrace{(x+dx)(x+dx) \cdots (x+dx)}_{n\text{個}}
\end{equation}

右辺の$(x+dx)(x+dx) \cdots (x+dx)$を展開しようすると、次のような3種類のかけ算が発生する。

\begin{itemize}
  \item $x$どうしのかけ算
  \item $x$と$dx$のかけ算
  \item $dx$どうしのかけ算
\end{itemize}

つまり、右辺からは、

\begin{itemize}
  \item $x^n$の項が1つ
  \item $x^{n-1}dx$の項が$n$個
  \item $dx^n$の項が1つ
\end{itemize}

という項が現れることになる。

そして、$x^n$は左辺の$y$と相殺され、$dx^n$の項は高次の微小量として無視できる。

すると、残るのは次のような式になるだろう。

\begin{equation}
  dy = nx^{n-1}dx
\end{equation}

この式は、$y=\alpha x$という直線の式によく似ている。

高次の$dx$の項$dx^n$を無視し、1次の$dx$の項だけ残したのは、微分という計算が微小範囲における直線での近似であるからだ。

あくまでも微小範囲での直線の式であることを表すために、$x, y$を$dx, dy$として、$dy=\alpha dx$という形の式になっていると考えればよい。

\begin{theorem}{自然数の冪を持つ冪関数の導関数}
  \newline
  $n$が自然数のとき、$y=x^n$の導関数は次のようになる。
  \Large
  \begin{equation}
    \frac{dy}{dx} = nx^{n-1}
  \end{equation}
\end{theorem}

\subsubsection{$y=x^n$の微分（$n$が整数の場合）}

指数法則を使うことで、$n$が負の整数の場合にも拡張することができる。

\vskip\baselineskip

まずは、$y=x^{-1}$の微分を考えてみよう。

指数法則より、$y=x^{-1}$は次のように変形できる。

\begin{equation}
  \begin{WithArrows}
    y  & = \dfrac{1}{x} \Arrow{両辺$\times x$} \\
    xy & = 1
  \end{WithArrows}
\end{equation}

微小変化を加えた微分の関係式を作って、次のように展開していく。

\begin{align}
  (x +dx)(y+dy)                                                                                   & = 1                           \\
  \eqnmarkbox[magenta]{Y1}{xy} + xdy + ydx + \fitLabelMath[BlueGreen][BlueGreen!40]{dydx}{高次の微小量} & = \eqnmarkbox[magenta]{Y2}{1}
\end{align}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

ここで、微小量の掛け合わせである$dydx$は無視できるほど小さい。

また、$y=\dfrac{1}{x}$より、$xy=1$なので、左辺の$xy$と右辺の$1$は相殺される。

すると、残った式は、

\begin{equation}
  \begin{WithArrows}
    xdy + ydx       & = 0            \Arrow{$ydx$を移項} \\
    xdy             & = -ydx         \Arrow{両辺$\div dx$} \\
    x\dfrac{dy}{dx} & = -y           \Arrow{両辺$\div x$} \\
    \dfrac{dy}{dx}  & = -\dfrac{y}{x}
  \end{WithArrows}
\end{equation}

$y$が残ってしまっているので、$y=\dfrac{1}{x}$を代入すると、

\begin{align}
  \dfrac{dy}{dx} & = -\dfrac{1}{x^2} \\
                 & = -x^{-2}
\end{align}

これは、冪が自然数の場合の冪関数の微分$\dfrac{dy}{dx} = nx^{n-1}$において、$n = -1$を代入したものになっている。

\vskip\baselineskip

$n$が任意の負の整数の場合も、同様に考えられる。

$y=x^{-n}$を、$x^ny = 1$として、

\begin{equation}
  \begin{WithArrows}
    \underbrace{(x+dx)(x+dx) \cdots (x+dx)}_{n\text{個}}\times(y+dy)                           & = 1 \\
    ( x^n + nx^{n-1}dx + \fitLabelMath[BlueGreen][BlueGreen!40]{dx^n}{高次の微小量} ) \times (y+dy) & = 1 \Arrow{高次の微小量を無視} \\
    ( x^n + nx^{n-1}dx ) \times (y+dy)                                                        & = 1 \\
    \eqnmarkbox[magenta]{Y1}{x^ny} + x^ndy + nx^{n-1}ydx + \fitLabelMath[BlueGreen][BlueGreen!40]{nx^{n-1}dxdy}{高次の微小量}                                           & = \eqnmarkbox[magenta]{Y2}{1} \Arrow[jump=2]{相殺＆無視}\\\\
    x^ndy + nx^{n-1}ydx & = 0
  \end{WithArrows}
\end{equation}
\annotatetwo{below}{Y1}{Y2}{\bfseries 同じ}

移項してさらに整理すると、

\begin{equation}
  \begin{WithArrows}
    x^ndy & = -nx^{n-1}ydx \Arrow{両辺$\div dx$} \\
    x^n\dfrac{dy}{dx} & = -nx^{n-1}y \Arrow{両辺$\times x^{-n}$} \\
    \dfrac{dy}{dx} & = -nx^{n-1}x^{-n}y \Arrow{$y=x^{-n}$} \\
    &= -nx^{n-1}x^{-n}x^{-n} \Arrow{指数法則$x^mx^n=x^{m+n}$} \\
    &= -nx^{-n-1}
  \end{WithArrows}
\end{equation}

これもやはり、冪が自然数の場合の冪関数の微分$\dfrac{dy}{dx} = nx^{n-1}$において、$n$を$-n$に置き換えたものになっている。

つまり、自然数（正の整数）だけでなく、負の整数も許容して、次のことがいえる。

\begin{theorem}{整数の冪を持つ冪関数の導関数}
  \newline
  $n$が整数のとき、$y=x^n$の導関数は次のようになる。
  \Large
  \begin{equation}
    \frac{dy}{dx} = nx^{n-1}
  \end{equation}
\end{theorem}

\subsubsection{$y=x^n$の微分（$n$が実数の場合）}

$n$が有理数の場合はどうだろうか。実はこれも、指数法則によって拡張することができる。

$m$と$n$はどちらも自然数として、$y=x^{\frac{m}{n}}$の微分を考える。

\vskip\baselineskip

まず、$y=x^{\frac{m}{n}}$は、$y^n = x^m$とまったく同じ式である。

\begin{equation}
  \begin{WithArrows}
    y^n & = x^m \Arrow{両辺$\dfrac{1}{n}$乗} \\
    y & = x^{\frac{m}{n}}
  \end{WithArrows}
\end{equation}

というわけで、$y^n = x^m$を微小変化させて、展開してみよう。

\begin{equation}
  \underbrace{(y+dy)(y+dy) \cdots (y+dy)}_{n\text{個}} = \underbrace{(x+dx)(x+dx) \cdots (x+dx)}_{m\text{個}}
\end{equation}

ここで、$n$と$m$は自然数なのだから、自然数冪のときと同じように考えて、次のような式が残ることになる。

\begin{equation}
  ny^{n-1}dy = mx^{m-1}dx
\end{equation}

よって、$\dfrac{dy}{dx}$の式の$y$を含まない形を目指すと、

\begin{equation}
  \begin{WithArrows}
    \dfrac{dy}{dx} &= \dfrac{mx^{m-1}}{ny^{n-1}} \Arrow{$y=x^{\frac{m}{n}}$} \\
    &= \dfrac{mx^{m-1}}{nx^{\frac{m}{n}(n-1)}} \\
    &= \dfrac{mx^{m-1}}{nx^{m - \frac{m}{n}}} \Arrow{指数法則$x^{a+b} = x^a x^b$} \\
    &= \dfrac{mx^m x^{-1}}{nx^mx^{-\frac{m}{n}}} \Arrow{$x^m$で約分} \\
    &= \dfrac{mx^{-1}}{n x^{-\frac{m}{n}}} \\
    &= \dfrac{m}{n}\cdot\dfrac{x^{-1}}{x^{-\frac{m}{n}}} \Arrow{指数法則$\dfrac{a^m}{a^n}=a^{m-n}$} \\
    &= \dfrac{m}{n}\cdot x^{-1-\left(-\frac{m}{n}\right)} \\
    &= \dfrac{m}{n}\cdot x^{-1 + \frac{m}{n}} \\
    &= \dfrac{m}{n}x^{\frac{m}{n}-1}
  \end{WithArrows}
\end{equation}

これは、冪が自然数の場合の冪関数の微分$\dfrac{dy}{dx} = nx^{n-1}$において、$n$を$\dfrac{m}{n}$に置き換えたものになっている。

つまり、整数だけでなく、有理数に対しても同様の導関数の式が成り立つ。

\vskip\baselineskip

ここまで来ると、無理数はどうだろうか？という疑問が生まれるが、無理数への拡張は指数法則では対応できない。

無理数に対しては、極限操作によって同様の導関数の式を導くことができ、実数全体に対して同じ導関数の式が成り立つことが示される。

\begin{theorem}{冪関数の導関数}
  \newline
  $n$が実数のとき、$y=x^n$の導関数は次のようになる。
  \Large
  \begin{equation}
    \frac{dy}{dx} = nx^{n-1}
  \end{equation}
\end{theorem}

\subsection{合成関数の微分}

\begin{theorem}{合成関数の微分}
  \Large
  \begin{equation}
    \left( g(f(x)) \right)' = f'(x)g'(f(x))
  \end{equation}
\end{theorem}

\subsection{三角関数の微分}

\begin{center}
  \scalebox{2}{
    \begin{tikzpicture}[scale=3]
      \coordinate (A) at (1,0);
      \coordinate (O) at (0,0);
      \coordinate (C1) at (30:1cm);
      \coordinate (C2) at (40:1cm);
      \coordinate (H) at (C1 |- O);
      % Hのx座標とC2のy座標を持つ点
      \coordinate (H2) at (C2 -| H);

      % OとAを結ぶ線
      \draw (O) -- (A);
      % OとC1を結ぶ線
      \draw (O) -- (C1);
      % OとC2を結ぶ線
      \draw (O) -- (C2);

      % 三角形O-H-C1
      \draw[fill=myPurple, opacity=0.6] (O) -- (H) -- (C1) -- cycle;
      % 三角形C1-H-C2
      \draw[fill=myPurple, opacity=0.6] (C2) -- (H2) -- (C1) -- cycle;

      % 角A-O-C1を表す扇形
      \draw (A) -- (O) -- (C1) pic [fill=cyan!50, angle radius=9mm, "$\theta$"] {angle = A--O--C1};
      % 角C1-O-C2を表す扇形
      \draw (C1) -- (O) -- (C2) pic [fill=magenta!40, angle radius=9mm] {angle = C1--O--C2};
      % 角C1-H-C2を表す扇形
      \draw (H2) -- (C1) -- (C2) pic [fill=cyan!60, angle radius=2mm] {angle = H2--C1--C2};

      % 直角O-H-C1
      \draw (O) -- (H) -- (C1) pic [fill=lightgray, angle radius=1.25mm] {right angle = O--H--C1};
      % 直角O-C1-C2
      \draw (O) -- (C1) --(C2) pic [fill=lightgray, angle radius=0.9mm] {right angle = O--C1--C2};
      % 直角C1-H2-C2
      \draw (C1) -- (H2) -- (C2) pic [fill=lightgray, angle radius=0.75mm] {right angle = C1--H2--C2};

      % AからC1を結ぶ円弧
      \draw[cyan, thick] (A) arc (0:30:1cm) node [midway, above, right] {$\theta$};
      % C1からC2を結ぶ円弧
      \draw[magenta, thick] (C1) arc (30:40:1cm) node [midway,sloped, below] {$d\theta$};

      % C1からH2の高さを表すベクトル
      \draw[<->] ($(C1)+ (0.05, 0)$) -- ($(H2)+(0.05,0)$) node [midway, right] {$d\theta\cos \theta$};
      % C2からH2の幅を表すベクトル
      \draw[<->] ($(C2)+ (0, 0.05)$) -- ($(H2)+(0,0.05)$) node [midway, above] {$d\theta\sin \theta$};

      % OからC2の長さを表すベクトル
      \draw [<->, orange] to ($(O)!0.05!90:(C2)$) -- ($(C2)!-0.05!90:(O)$) node [midway, above, orange] { $1$ };
      % OからAの長さを表すベクトル
      \draw [<->, orange] to ($(O)-(0,0.05)$) -- ($(A)-(0,0.05)$) node [midway, below, orange] { $1$ };

      % % sin\thetaを表すベクトル
      % \draw [<->] to ($(C1)+(0.05,0)$) -- ($(H)+(0.05,0)$) node [midway, left] { $\sin \theta$ };
      % % cos\thetaを表すベクトル
      % \draw [<->] to ($(H)-(0,0.05)$) -- ($(O)-(0,0.05)$) node [midway, below] { $\cos \theta$ };
    \end{tikzpicture}
  }
\end{center}

\subsection{ネイピア数}

指数関数を定義した際に、「どんな数も$0$乗したら$1$になる」と定義した。

つまり、指数関数$y=a^x$において、$x=0$での関数の値は$1$である。

ここでさらに、$x=0$でのグラフの傾きも$1$となるような$a$を探し、その値をネイピア数と呼ぶことにする。

\begin{definition}{ネイピア数（自然対数の底）}
  \newline
  指数関数$y=a^x$において、$x=0$での接線の傾きが$1$となるような底$a$の値をネイピア数と呼び、$e$と表す。
\end{definition}

この定義では、「$x=0$では関数の値も傾きも等しく$1$になる」という、$x=0$での振る舞いにしか言及していない。

だが、実はネイピア数を底とする指数関数は、「微分しても変わらない（すべての$x$において、関数の値と傾きが一致する）」という性質を持つ。

\subsection{ネイピア数を底とする指数関数の微分}

指数関数$y=e^x$の微分は、微分の定義から次のように計算できる。

\begin{align}
  \dfrac{d}{dx}e^x & = \lim_{\Delta x \to 0} \dfrac{e^{x+\Delta x} - e^x}{\Delta x}         \\
                   & = \lim_{\Delta x \to 0} \dfrac{e^x \cdot e^{\Delta x} - e^x}{\Delta x} \\
                   & = \lim_{\Delta x \to 0} \dfrac{e^x \cdot (e^{\Delta x} - 1)}{\Delta x} \\
                   & = e^x \cdot \lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x}
\end{align}

ここで、$\displaystyle\lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x}$は$x$によらない定数であり、

\begin{align}
  \lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x} & = \lim_{\Delta x \to 0} \dfrac{e^{0 + \Delta x} - e^0}{\Delta x}
\end{align}

というように、これは$x=0$における傾き（導関数に$x=0$を代入したもの）を表している。

そもそも、ネイピア数$e$の定義は「$x=0$での$e^x$の傾きが$1$」というものだったので、

\begin{equation}
  \lim_{\Delta x \to 0} \dfrac{e^{\Delta x} - 1}{\Delta x} = 1
\end{equation}

となり、「$e^x$は微分しても変わらない」という性質が導かれる。

\begin{equation}
  \dfrac{d}{dx}e^x = e^x
\end{equation}

\begin{theorem}{ネイピア数を底とする指数関数の微分}
  \newline
  ネイピア数を底とする指数関数は、微分しても変わらない関数である。
  \LARGE
  \begin{equation}
    \dfrac{d}{dx}e^x = e^x
  \end{equation}
\end{theorem}

\section{1変数関数の積分}

積分とは、「部分を積み重ねる」演算である。

微小部分を調べる微分と、微小部分を積み重ねる積分は、互いに逆の操作になっている。

\subsection{区分求積法：面積の再定義}

長方形の面積は、なぜ「縦$\times$横」で求められるのだろうか？

そこには、長方形の横幅分の長さを持つ線分を、長方形の高さに達するまで積み重ねるという発想がある。

\vskip\baselineskip

面積の計算を「線を積み重ねる」という発想で捉えると、あらゆる形状の面積を考えることができる。

長方形では、積み重ねる線の長さは一定だが、他の形状では、積み重ねる線の長さが変化する。

積み重ねるべき線の長さを、関数で表すことができたら…

\froufrou

関数$y=f(x)$が与えられたとき、高さ$f(x)$の線分を$a$から$b$までの区間で積み重ねることで、$x$軸とグラフに挟まれた部分の面積を求めることを考える。

\begin{center}
  \begin{tikzpicture}[
      scale=0.9,
      declare function={f(\x)=((1/3)*(\x)^(3)-3*(\x)^(2)+8*\x-3;},
      lnode/.style={text height=1em}
    ]
    % 積分区間全体を塗りつぶす
    \draw[fill=cyan!30, draw=cyan!70!gray] plot[domain=1:5,samples=167,variable=\x] ({\x},{f(\x)}) -- (5,0) -| cycle;

    % 積分区間の下端のラベル
    \node [anchor=north,lnode] at (1,0) {$a$};
    % 積分区間の上端のラベル
    \node[anchor=north,lnode] at (5,0pt) {$b$};

    % x軸とy軸
    \draw [axis] (-0.5,0) -- (6,0) node (xaxis) [below] {$x$};
    \draw [axis] (0,-0.5) -- (0,5) node [left] {$y$};

    % 原点
    \node [below left] at (0,0) {$O$};

    % 関数のグラフ
    \draw[domain=.5:5.3,samples=200,variable=\x,BurntOrange,very thick] plot ({\x},{f(\x)}) node [above right] {$y=f(x)$};
  \end{tikzpicture}
\end{center}

この考え方は、面積を求めたい部分を長方形に分割し、長方形の幅を限りなく$0$に近づけるという操作で表現できる。

\begin{center}
  \begin{tikzpicture}[
      declare function={f(\x)=((1/3)*(\x)^(3)-3*(\x)^(2)+8*\x-3;},
      lnode/.style={text height=1em}
    ]
    \begin{scope}[scale=0.9, local bounding box=left]
      \def\N{5}
      \pgfmathtruncatemacro{\M}{\N/4}

      \coordinate (start) at (.8,{f(.8)});

      \ifnum\N<22
        \foreach \X [remember=\X as \LastX (initially 0)] in {1,...,\N}
          {
            % 矩形
            \draw[fill=cyan!30, draw=cyan!70!gray] (1+\LastX*4/\N,0) rectangle (1+\X*4/\N,{f(1+\LastX*4/\N)});
            % 矩形の左上の頂点
            \draw[fill=cyan, draw=cyan] (1+\LastX*4/\N,{f(1+\LastX*4/\N)}) circle (2pt) ;

            % x軸上のラベル
            \path (1+\LastX*4/\N,0pt) coordinate (x\X);
            \ifnum\X=1
              % 積分区間の下端のラベル
              \node[anchor=north east,xshift=0.75em,lnode] at (1+\LastX*4/\N,0pt) {$a=x_{\X}$};
            \else
              % 積分区間内の各点のラベル
              \pgfmathtruncatemacro{\itest}{mod(\X,\M)}
              % 4等分した点のみラベルをつける
              \ifnum\itest=0
                \pgfmathsetmacro{\dist}{4-\LastX*4/\N}
                % 5pt以上離れている場合のみラベルをつける
                \ifdim\dist cm>5pt
                  \node [anchor=north,lnode] at (1+\LastX*4/\N,0pt) {$x_{\X}$};
                \fi
              \fi
            \fi
          }

        % \Delta x の幅を示す矢印
        \draw[<->] (x2|- 0,-1)--(x3|- 0,-1) node[above,midway] {$\Delta x$};
      \else
        % 22個以上の場合は積分区間全体を塗りつぶす
        \draw[fill=cyan!30, draw=cyan!70!gray] plot[domain=1:5,samples=167,variable=\x] ({\x},{f(\x)}) -- (5,0) -| cycle;

        % 積分区間の下端のラベル
        \node [anchor=north,lnode] at (1,0) {$a$};
      \fi

      \coordinate (end) at (5.05,{f(5.05)});

      % 積分区間の上端のラベル
      \node[anchor=north,lnode] at (5,0pt) {$b$};

      % 積分区間の上端におけるグラフの高さを示す線
      \draw [draw=cyan!70!gray] (5,0)--(5,{f(5)});

      % x軸とy軸
      \draw [axis] (-0.5,0) -- (6,0) node (xaxis) [below] {$x$};
      \draw [axis] (0,-0.5) -- (0,5) node [left] {$y$};

      % 原点
      \node [below left] at (0,0) {$O$};

      % 関数のグラフ
      \draw[domain=.5:5.3,samples=200,variable=\x,BurntOrange,very thick] plot ({\x},{f(\x)});
    \end{scope}

    \begin{scope}[scale=0.9, xshift=0.6\textwidth, local bounding box=right]
      \def\N{14}
      \pgfmathtruncatemacro{\M}{\N/4}

      \coordinate (start) at (.8,{f(.8)});

      \ifnum\N<22
        \foreach \X [remember=\X as \LastX (initially 0)] in {1,...,\N}
          {
            % 矩形
            \draw[fill=cyan!30, draw=cyan!70!gray] (1+\LastX*4/\N,0) rectangle (1+\X*4/\N,{f(1+\LastX*4/\N)});
            % 矩形の左上の頂点
            \draw[fill=cyan, draw=cyan] (1+\LastX*4/\N,{f(1+\LastX*4/\N)}) circle (2pt) ;

            % x軸上のラベル
            \path (1+\LastX*4/\N,0pt) coordinate (x\X);
            \ifnum\X=1
              % 積分区間の下端のラベル
              \node[anchor=north east,xshift=0.75em,lnode] at (1+\LastX*4/\N,0pt) {$a=x_{\X}$};
            \else
              % 積分区間内の各点のラベル
              \pgfmathtruncatemacro{\itest}{mod(\X,\M)}
              % 4等分した点のみラベルをつける
              \ifnum\itest=0
                \pgfmathsetmacro{\dist}{4-\LastX*4/\N}
                % 5pt以上離れている場合のみラベルをつける
                \ifdim\dist cm>5pt
                  \node [anchor=north,lnode] at (1+\LastX*4/\N,0pt) {$x_{\X}$};
                \fi
              \fi
            \fi
          }

        % \Delta x の幅を示す矢印
        \draw[<->] (x2|- 0,-1)--(x3|- 0,-1) node[above,midway] {$\Delta x$};
      \else
        % 22個以上の場合は積分区間全体を塗りつぶす
        \draw[fill=cyan!30, draw=cyan!70!gray] plot[domain=1:5,samples=167,variable=\x] ({\x},{f(\x)}) -- (5,0) -| cycle;

        % 積分区間の下端のラベル
        \node [anchor=north,lnode] at (1,0) {$a$};
      \fi

      \coordinate (end) at (5.05,{f(5.05)});

      % 積分区間の上端のラベル
      \node[anchor=north,lnode] at (5,0pt) {$b$};

      % 積分区間の上端におけるグラフの高さを示す線
      \draw [draw=cyan!70!gray] (5,0)--(5,{f(5)});

      % x軸とy軸
      \draw [axis] (-0.5,0) -- (6,0) node (xaxis) [below] {$x$};
      \draw [axis] (0,-0.5) -- (0,5) node [left] {$y$};

      % 原点
      \node [below left] at (0,0) {$O$};

      % 関数のグラフ
      \draw[domain=.5:5.3,samples=200,variable=\x,BurntOrange,very thick] plot ({\x},{f(\x)});
    \end{scope}

    \draw[->, thick] ($(left.east)+(1em, 0)$) -- ($(left-|right.west)-(1em,0)$) node[pos=.5, above] {$\Delta x$小};
  \end{tikzpicture}
\end{center}

$a \leq x \leq b$の区間を$n$等分して、$x_1, x_2, \ldots, x_n$とする。

分割された各長方形は、幅が$\Delta x$で、高さが$f(x)$であるので、各長方形の面積は次のように表せる。

\begin{equation}
  \Delta S = f(x) \cdot \Delta x
\end{equation}

どんどん$\Delta x$を小さくしていくと、細かい長方形分割で、面積を求めたい図形を近似できる。

\begin{center}
  \begin{tikzpicture}[
      scale=1.2,
      declare function={f(\x)=((1/3)*(\x)^(3)-3*(\x)^(2)+8*\x-3;},
      lnode/.style={text height=1em}
    ]
    \def\N{40}
    \pgfmathtruncatemacro{\M}{\N/4}

    \coordinate (start) at (.8,{f(.8)});

    \foreach \X [remember=\X as \LastX (initially 0)] in {1,...,\N}
    {
    % 矩形
    \draw[fill=cyan!30, draw=cyan!70!gray] (1+\LastX*4/\N,0) rectangle (1+\X*4/\N,{f(1+\LastX*4/\N)});
    % 矩形の左上の頂点
    \draw[fill=cyan, draw=cyan] (1+\LastX*4/\N,{f(1+\LastX*4/\N)}) circle (1pt) ;

    % x軸上のラベル
    \path (1+\LastX*4/\N,0pt) coordinate (x\X);
    \ifnum\X=1
      % 積分区間の下端のラベル
      \node[anchor=north east,xshift=0.75em,lnode] at (1+\LastX*4/\N,0pt) {$a=x_{\X}$};
    \else
      % 積分区間内の各点のラベル
      \pgfmathtruncatemacro{\itest}{mod(\X,\M)}
      % 4等分した点のみラベルをつける
      \ifnum\itest=0
        \pgfmathsetmacro{\dist}{4-\LastX*4/\N}
        % 5pt以上離れている場合のみラベルをつける
        \ifdim\dist cm>5pt
          \node [anchor=north,lnode] at (1+\LastX*4/\N,0pt) {$x_{\X}$};
        \fi
      \fi
    \fi
    }

    \coordinate (end) at (5.05,{f(5.05)});

    % 積分区間の上端のラベル
    \node[anchor=north,lnode] at (5,0pt) {$b$};

    % 積分区間の上端におけるグラフの高さを示す線
    \draw [draw=cyan!70!gray] (5,0)--(5,{f(5)});

    % x軸とy軸
    \draw [axis] (-0.5,0) -- (6,0) node (xaxis) [below] {$x$};
    \draw [axis] (0,-0.5) -- (0,5) node [left] {$y$};

    % 原点
    \node [below left] at (0,0) {$O$};

    % 関数のグラフ
    \draw[domain=.5:5.3,samples=200,variable=\x,BurntOrange,very thick] plot ({\x},{f(\x)}) node [above right] {$y=f(x)$};
  \end{tikzpicture}
\end{center}

つまり、求めたい面積は、分割した長方形の面積をすべて足し合わせることで近似できる。

\begin{equation}
  S \approx \sum_{i=1}^{n} f(x_i) \cdot \Delta x
\end{equation}

$\Delta x \to 0$の果てでは、幅を持たなくなった長方形は線分とみなせるので、もはや近似ですらなくなるだろう。

\begin{equation}
  S = \lim_{\Delta x \to 0} \sum_{i=1}^{n} f(x_i) \cdot \Delta x
\end{equation}

このような考え方は、区分求積法と呼ばれる。

\subsection{定積分：面積を求める積分}

ここで、区間$a \leq x \leq b$における関数$y=f(x)$と$x$軸の間の面積$S$を求める式を、次のように表記する。

\begin{equation}
  S = \int_{a}^{b} f(x) \, dx
\end{equation}

$\sum$は離散的な和を表す記号であり、例えば$\displaystyle\sum_{i=0}^n$であれば、$i$を$1$ずつ増やして$n$に達するまで足し合わせることを意味する。

一方、ここで新たに導入した$\int$は連続的な和を表す記号であり、微小変化を繰り返しながら足し合わせることを意味する。

\vskip\baselineskip

$\sum$は間隔を取って足し合わせるのに対し、$\int$は間隔を限りなく小さくして足し合わせる。

足し合わせる間隔を限りなく小さくするという操作は、極限を取る操作に相当するので、$\sum$の極限を取ったもの$\displaystyle \lim \sum$をまとめて$\int$という記号で表記したと捉えることができる。

さらに、$\displaystyle\lim_{\Delta x \to 0}$とした果ての$\Delta x$は、微小変化を意味する$dx$と書き換えられている。

\begin{definition}{定積分}
  \newline
  $a \leq x \leq b$の区間内における関数$f(x)$のグラフと$x$軸の間の領域の符号付き面積を求める演算を定積分と定義し、次のように表記する。
  \LARGE
  \begin{equation}
    \int_{a}^{b} f(x) dx
  \end{equation}
  \normalsize
  このとき、$f(x)$を被積分関数と呼ぶ。
\end{definition}

$f(x)$の値が負になる区間では、定積分の値も負になるため、定積分は符号付き面積を表す。

\begin{center}
  \begin{tikzpicture}
    \begin{axis}[
        name=myaxis,
        axis y line = none,
        axis x line = none,
        xmin=-3, xmax=3,
        ymin=-10, ymax=10,
        declare function={
            fn(\x) = 3*\x^3 - \x^2 - 10*\x;
          }
      ]
      % 関数f(x)のプロット
      \addplot [domain=-2:2.25, samples=100, name path=f, very thick, color=BurntOrange]
      {fn{\x}};

      % x軸
      \addplot [name path=xaxis] {0};

      % xaxisとfの交点
      \path [name intersections={of=f and xaxis, by={I1,I2,I3}}];

      % x軸上のラベル
      \node [below, name=a, magenta, text height=0.75em] at ($(I1) + 1/3*(1cm,0)$) {$a_1$};
      \node [below, name=b, magenta, text height=0.75em] at ($(I2) - 1/3*(1cm,0)$) {$b_1$};
      \node [above, name=c, cyan, text height=0.75em] at ($(I2) + 2/5*(1cm,0)$) {$a_2$};
      \node [above, name=d, cyan, text height=0.75em] at ($(I3) - 2/5*(1cm,0)$) {$b_2$};

      % 各点のx座標を取り出してレジスタに保存
      \pgfplotsextra{
        \pgfplotspointgetcoordinates{(a)}
        \pgfkeysgetvalue{/data point/x}{\ax}

        \pgfplotspointgetcoordinates{(b)}
        \pgfkeysgetvalue{/data point/x}{\bx}

        \pgfplotspointgetcoordinates{(c)}
        \pgfkeysgetvalue{/data point/x}{\cx}

        \pgfplotspointgetcoordinates{(d)}
        \pgfkeysgetvalue{/data point/x}{\dx}
      }

      % [a, b]区間の定積分
      \addplot [
        opacity=0.8, postaction={pattern=north east lines}, magenta!30, pattern color=magenta!80!gray] fill between [
          of=f and xaxis, soft clip={domain=\ax:\bx},
        ];
      % [c, d]区間の定積分
      \addplot [
        opacity=0.8, postaction={pattern=north east lines}, cyan!30, pattern color=cyan!80!gray] fill between [
          of=f and xaxis, soft clip={domain=\cx:\dx},
        ];
    \end{axis}

    % x軸
    \draw [axis] (myaxis.west) -- (myaxis.east) node [right] {$x$};
  \end{tikzpicture}
\end{center}

\subsection{微小範囲の定積分から微分へ}

定積分$\displaystyle\int_{a}^{b}f(x)dx$は、積分区間の取り方（$a$や$b$の値）を変えると、当然異なる計算結果になる。

\vskip\baselineskip

ここで、下端$a$は固定し、上端$b$を変化させて積分区間を広げていくことを考えよう。

変化する上端を表す変数として、$u$を導入する。

このとき、定積分$\displaystyle\int_{a}^{u}f(x)dx$は、上端$u$の関数として捉えられる。

\begin{equation}
  S(u) = \int_{a}^{u} f(x) dx
\end{equation}

\begin{center}
  \begin{tikzpicture}[
      scale=0.9,
      declare function={f(\x)=((1/3)*(\x)^(3)-3*(\x)^(2)+8*\x-3;},
      lnode/.style={text height=1em}
    ]
    \def\a{1}
    \def\u{4.5}
    \def\du{0.5}

    % 積分区間[a,u]
    \draw[fill=lightgray!20, draw=lightgray!80!gray] plot[domain=\a:\u,samples=167,variable=\x] ({\x},{f(\x)}) -- (\u,0) -| cycle;
    % ↑の領域の中央に、定積分の式のラベルを配置
    \node[gray] at ({(\a+\u)/2},{f((\a+\u)/2)/2}) {$\displaystyle\int_{a}^{u}f(x)dx$};

    % [u, u+du]
    \draw[fill=magenta!30, draw=magenta!70!gray] plot[domain=\u:\u+\du,samples=167,variable=\x] ({\x},{f(\x)}) -- (\u+\du,0) -| cycle;

    % 積分区間の下端のラベル
    \node [anchor=north,lnode] at (\a,0) {$a$};
    % 積分区間の上端のラベル
    \node[anchor=north,lnode] at (\u,0) {$u$};
    % u+duのラベル
    \node[anchor=north,lnode, below right, xshift=-0.5em] at (\u+\du,0) {$u+\Delta u$};

    % (u, f(u))の点
    \fill[magenta] (\u,{f(\u)}) circle (2pt) node [above left] {$f(u)$};
    % (u+du, f(u+du))の点
    \fill[magenta] (\u+\du,{f(\u+\du)}) circle (2pt) node [right] {$f(u+\Delta u)$};

    % x軸とy軸
    \draw [axis] (-0.5,0) -- (\u+\du+2,0) node (xaxis) [below] {$x$};
    \draw [axis] (0,-0.5) -- (0,5) node [left] {$y$};

    % duの幅を表す矢印
    \draw [<->, magenta] ($(\u,-1.25em)+(0.2em,-1.25em)$) -- ($(\u+\du,-1.25em)+(-0.2em,-1.25em)$) node [below, midway, magenta] {$\Delta u$};

    % 原点
    \node [below left] at (0,0) {$O$};

    % 関数のグラフ
    \draw[domain=.5:5.3,samples=200,variable=\x,BurntOrange,very thick] plot ({\x},{f(\x)}) node [above right] {$y=f(x)$};
  \end{tikzpicture}
\end{center}

$u$を$\Delta u$だけ増加させたときに増える面積は、

\begin{equation}
  S(u+\Delta u) - S(u) = \int_{u}^{u+\Delta u} f(x) dx
\end{equation}

となるが、ここでさらに$\Delta u$を小さくしていくと…

増えた領域は、幅$du$、高さ$f(u)$の長方形とみなせるので、その面積は$f(u)du$となる。

\begin{center}
  \begin{tikzpicture}[
      scale=0.9,
      declare function={f(\x)=((1/3)*(\x)^(3)-3*(\x)^(2)+8*\x-3;},
      lnode/.style={text height=1em}
    ]
    \def\a{1}
    \def\u{4.5}
    \def\du{0.05}

    % 積分区間[a,u]
    \draw[fill=lightgray!20, draw=lightgray!80!gray] plot[domain=\a:\u,samples=167,variable=\x] ({\x},{f(\x)}) -- (\u,0) -| cycle;
    % ↑の領域の中央に、定積分の式のラベルを配置
    \node[gray] at ({(\a+\u)/2},{f((\a+\u)/2)/2}) {$\displaystyle\int_{a}^{u}f(x)dx$};

    % [u, u+du]
    \draw[fill=magenta!30, draw=magenta!70!gray] plot[domain=\u:\u+\du,samples=167,variable=\x] ({\x},{f(\x)}) -- (\u+\du,0) -| cycle;

    % 積分区間の下端のラベル
    \node [anchor=north,lnode] at (\a,0) {$a$};
    % 積分区間の上端のラベル
    \node[anchor=north,lnode, below right, xshift=-0.5em] at (\u,0) {$u \approx u+du$};

    % (u, f(u))の点
    \fill[magenta] (\u,{f(\u)}) circle (2pt) node [right] {$f(u) \approx f(u+du)$};

    % x軸とy軸
    \draw [axis] (-0.5,0) -- (\u+\du+2,0) node (xaxis) [below] {$x$};
    \draw [axis] (0,-0.5) -- (0,5) node [left] {$y$};

    % 原点
    \node [below left] at (0,0) {$O$};

    % 関数のグラフ
    \draw[domain=.5:5.3,samples=200,variable=\x,BurntOrange,very thick] plot ({\x},{f(\x)}) node [above right] {$y=f(x)$};
  \end{tikzpicture}
\end{center}

よって、$\Delta u\to 0$としたときには、

\begin{equation}
  S(u+du) - S(u) = f(u)du
\end{equation}

という式が成り立ち、これは実は見慣れた微分の関係式と同じ形をしている。

\begin{equation}
  S(u+du) = \origFn{S(u)} + \derivFn{f(u)}du
\end{equation}

この式は、定積分したもの$F(u)$を$u$で微分すると、積分前の関数$f(u)$に戻るということを示している。

このような「積分したものを微分すると、元の関数に戻る」という事実は、微積分学の基本定理として知られている。

\begin{theorem}{微積分学の基本定理}
  積分の逆の演算は微分である。
\end{theorem}

\subsection{不定積分：原始関数を求める積分}

定積分の定義は面積から始まったが、定積分という操作で「微分したら元の関数に戻る」ような関数を作ることもできた。

ここで、「微分したら元の関数に戻る」関数を次のように定義する。

\begin{definition}{原始関数}
  \newline
  微分することで元の関数$f(x)$が得られる関数を、$f(x)$の\hl{原始関数}と呼び、$F(x)$と表す。
  \LARGE
  \begin{equation}
    f(x) = \frac{d}{dx} F(x)
  \end{equation}
\end{definition}

「微分したら元の関数に戻る」関数の1つが、前節で調べた$S(u) = \displaystyle\int_{a}^{u} f(x) dx$であったが、実はこのような関数は他にも存在する。

例えば、定数を微分すると$0$になるため、$S(u)$に任意の定数$C$を加えた関数$S(u) + C$を作っても、その微分結果は変わらず元の関数になる。

このことは、「原始関数には定数$C$分の不定性がある」などと表現されることがある。

\vskip\baselineskip

「微分したら元の関数に戻る」関数を求める演算、すなわち「微分の逆演算」として捉えた積分を新たに定義してみよう。

\begin{definition}{不定積分}
  \newline
  関数$f(x)$から原始関数$F(x)$を求める演算を、$f(x)$の\hl{不定積分}と呼び、次のように表す。
  \LARGE
  \begin{equation}
    \int f(x) dx = F(x) + C
  \end{equation}
  \normalsize
  ここで、$C$は\hl{積分定数}と呼ばれる任意の定数である。
\end{definition}

\end{document}